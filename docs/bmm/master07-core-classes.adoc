= Classes

== Overview

This section describes the semantics of the `BMM_CLASS` meta-class, its sub-types, constituent parts and relationships. The parts of a class are collectively known as _features_, and consist of functions, procedures, constants and properties. The following UML illustrates classes and relationships to constituent feature meta-types. (Features are described in detail in the following section.)

[.text-center]
.`base.bmm.core` Package - Classes
image::{uml_diagrams_uri}/LANG-bmm.core-class.svg[id=core_class, align="center"]

Class definitions are the _definitional_ basis of a BMM model, i.e. they are the means of defining the types that are statically used in the model, and the dynamic types generated at runtime. Types are thus _derived_ entities.

BMM distinguishes between simple and generic class definitions via two descendants of `BMM_CLASS`, i.e. `BMM_SIMPLE_CLASS` and `BMM_GENERIC_CLASS`, with the first providing a concrete form of `BMM_CLASS` that applies to non-generic classes, and the latter defining the additional semantics of generic classes. The meta-type `BMM_ENUMERATION` is a specialisation of `BMM_SIMPLE_CLASS` used to represent enumeration classes in BMM models. The meta-types are further described below.

NOTE: not currently supported: export status; 'static' (non-instance dependent) methods; anchored types.

== Primitive Class Definitions

Class definitions within a BMM model may be marked as 'primitive', enabling them to be visualised and queried as a separate group without otherwise changing the semantics of the entity in the BMM meta-type system. This is normally done to state built-in data types used by a model from the classes for which the model was created. The following shows part of a BMM model in which a number of classes are classified as primitive (shown in light and dark grey).

[.text-center]
.Primitive classes
image::{images_uri}/awb_primitive_types.png[id=awb_primitive_types, align="center", width="45%"]

Primitive classes are normal BMM classes, other than being marked primitive for convenience, and do not have different semantics.

== Generic Class Meta-type

The generic class meta-type `BMM_GENERIC_CLASS` adds generic parameters to `BMM_CLASS`, enabling formal generic parameters to be represented. Each such parameter is expressed using an instance of `BMM_PARAMETER_TYPE` which names the parameter and optionally allows a type constraint to be associated with it, in the usual object-oriented fashion. In BMM, formal parameters have single-letter names, such as 'T', 'U' etc, following typical usage in programming languages. The following example shows a generic class `Interval<T:Ordered>`, which is a class `Interval` with one formal parameter `T` constrained to be of type `Ordered` or any descendant.

[.text-center]
.BMM class - generic class
image::{images_uri}/awb_generic_class.png[id=awb_generic_class, align="center", width="50%"]

== Range-Constrained Meta-types

The value range of any defined type is by default open, meaning that its instances may take any value allowed by the type definition. For primitive types such as `String` and `Integer`, this means that any String or Integer value is a valid instance. For composed types, instances are composed of hierarchies of values which are similarly un-constrained with respect to their types. A useful form of any concrete type definition (i.e. instance of `BMM_DEFINED_TYPE` in a model) is one that constrains the legal values of its instances to a particular set of values. The Pascal language provided a well-known precedent, 'sub-range types' that could restrict primitive type value ranges. BMM supports two kinds of range constraint: enumeration and 'value sets'. The additional meta-classes ar shown below.

[.text-center]
.`base.bmm.core` Package - Constrained-range Meta-Types, including Enumeration
image::{uml_diagrams_uri}/LANG-bmm.core-range_constrained.svg[id=core_range_constrained, align="center"]

=== Enumeration Class Meta-type

In modern programming languages, the _enumerated type_ is the most common kind of range constraint mechanism. In Java for example, an enumeration is a finite set of labels each associated with singleton value object - either automatically assigned integers, or else programmatically associated instances of any other kind. Enumerated types are supported in BMM via the `BMM_ENUMERATION` meta-type and descendants.

An enumerated type could in theory be based on any BMM defined type, i.e. any simple or generic type, since instances of either could be constrained. BMM makes the simplification that an enumerated type can only be based on a BMM simple type, which means that in the defined model, an enumeration of a closed generic type `Gen<T_subst>` is achieved by first defining a simple type based on the closed generic type via inheritance, in this case a type `Simple` that inherits from `Gen<T_subst>` can be used as the ancestor of a BMM enumeration type.

For this reason, the `BMM_ENUMERATION` meta-type is defined as a descendant of `BMM_SIMPLE_CLASS`, and may have only one ancestor. The value enumeration is represented via a set of enumeration labels (`_item_names_`) and constant values (`_item_values_`), the latter of which must be of the type represented in the concrete model by the instance of the ancestor class.

Since `String` and `Integer` valued enumerations are by far the most common in real models, two descendant classes `BMM_ENUMERATION_STRING` and `BMM_ENUMERATION_INTEGER` are provided, which fix the values and types to `String` and `Integer` respectively.

The following diagram shows the meta-model structure corresponding to an attribute declaration `_lifecycle_: TaskLifecycle` in a class `Order`.

[.text-center]
.Integer-based Enumeration Type
image::{diagrams_uri}/bmm_structure-enumeration.svg[id=bmm_structure_enumeration, align="center"]

The following screenshot shows how this enumeration class appears within a BMM model.

[.text-center]
.Enumeration Example
image::{images_uri}/awb_enumeration.png[id=awb_enumeration, align="center", width="65%"]

The types `String` and `Integer` are assumed to be defined via primitive classes of the same names.

=== Value-set Range-Constrained Meta-type

Another form of range constraint that occurs in many models is the use of 'coded terms' that represent codes from e.g. ISO or IANA value sets such as ISO 639 (languages) and IANA media types. These are particularly prevalent in type systems used in the biosciences where object models routinely include attributes of a Coded Term type that refer to terminologies such as {snomed_ct}[SNOMED CT], {who_icd}[WHO ICD10] etc. In such models, it is typical to want to define an attribute being not just of a Coded Term type, but also limited to a particular terminology (such as a coded attribute representing 'language'), or even a specific 'value set' from such a terminology.

The same kind of constraint may be applied to any kind of model type, for example a type representing Medication may be constrained to be instantiated only as instances defined by a medications database. This kind of constraint is known here as a _value set_, following the common usage in the biomedical sciences, and is supported in a different way than enumerations. The latter is a common programming concept which always involves a dedicated type representing the enumeration. Since the required value-sets are represented explicitly in the model but in an external database or other resource, the constraint is limited to a reference to the relevant resource, and is applied directly to _the use of a type within a feature definition_, rather than requiring the definition of a new type.

Accordingly, BMM provides the attribute `_value_constraint_: BMM_VALUE_SET_SPEC` defined on `BMM_DEFINED_TYPE`. The `BMM_VALUE_SET_SPEC` meta-type contains two `String` attributes `_resource_id_` and `_value_set_id_` which may be used to define a resource (equivalently a namespace) and an identifier of a value set within that resource. BMM does not impose any particular format or resolution algorithm on these identifiers - it is assumed that they can be correctly defined and used within the context of the concrete model usage.

Consequently, an attribute within a standard concrete model such as `_language_: CodedTerm` could now be expressed notionally as `_language_: CodedTerm \<<iso::639-*>>` or `_language_: CodedTerm \<<iso::languages>>`. The construction within the `<<>>` is parsed into two pieces around the `::` separator, which are then used to populate the `BMM_VALUE_SET_SPEC` for a type.

The following diagram shows the meta-model structure corresponding to an attribute declaration `_language_: CodedText` whose instances are constrained to be from a value-set `iso_639-2` within the resource namespace `iso`.

[.text-center]
.Value-set Constrained Type
image::{diagrams_uri}/bmm_structure-value_set.svg[id=bmm_structure_value_set, align="center"]

== Class Definitions

include::{uml_export_dir}/classes/bmm_class.adoc[]
include::{uml_export_dir}/classes/bmm_simple_class.adoc[]
include::{uml_export_dir}/classes/bmm_generic_class.adoc[]
include::{uml_export_dir}/classes/bmm_enumeration.adoc[]
include::{uml_export_dir}/classes/bmm_enumeration_string.adoc[]
include::{uml_export_dir}/classes/bmm_enumeration_integer.adoc[]
include::{uml_export_dir}/classes/bmm_value_set_spec.adoc[]
