= Functional Elements

== Overview

BMM provides support for representing functional entities, often known as {wikipedia_lambda_calculus}[lambdas^]. The relevant package is `bmm.core.functional`, shown below.

[.text-center]
.`base.bmm.core.functional` package - Functional Elements
image::{uml_diagrams_uri}/LANG-bmm.core.functional.svg[id=core_functional, align="center"]

A call to a routine may be formalised as a lambda expression, often termed as a 'function-as-object', more correctly understood as a _delayed routine call_. As described in <<Functions and Procedures>>, function and procedure are two specialisations of 'routine', where a procedure is a callable entity producing no return value. So-called functional programming generally deals with both types of calls.

There are three possible levels of expression of a callable routine within an object/functional model system that supports lambda expressions, as follows:

* _definition_: the definition of the routine, consisting at least of its interface, and possibly implementation;
* _routine type_: the specification of the _type_ of a routine such that a routine-call-as-object may be the type of an entity, including an argument or return type in another routine definition;
* _routine call_: an actual routine call, i.e. an invocation of a named routine with closed and potentially open arguments.

The first is dealt with in the `feature` package of this specification. The second can be understood as the _signature_ of a routine, and can be expressed as described earlier in <<_signatures>>.

The third is a kind of _value_ in the sense of the `BMM_VALUE` meta-type of this specification, i.e. a literal object, sometimes needed within model specifications.

The second and third categories are addressed in the `functional` package, and are described below.

== Routine Types and Signatures

The feature of a model or language that makes it functional is to allow the type of a _delayed call_ to be stated in the same way as any other type. Such types take the form of signatures, and are represented by the meta-type `BMM_ROUTINE_SIGNATURE`. Instances of this meta-type represent any kind of signature, in terms of `_arguments_`, whose meta-type is `BMM_TUPLE_TYPE` (See <<Tuple Type>>), and `_result_`, representing the result type.

The standard taxonomy of signature types is illustrated below, with each form being controlled by invariants stated in the relevant containing meta-classes (e.g. `BMM-FUNCION`, representing a function definition has an invariant requiring `signature.result /= Void`).

[.text-center]
.Signature taxonomy
image::{diagrams_uri}/signature_taxonomy.svg[id=signature_taxonomy, align="center", width="50%"]

Typical signatures expressed as type-tuples in a common syntactic form such as the following, are instances of this meta-types.

----
    []: Date                -- signature of a 0-order function like current_date()
    [Real, Real]: Real      -- signature of a 2nd-order function like '*' for the domain R
    
    [Real]                  -- a 1st-order procedure for the domain R
    [String, Integer]       -- signature of a procedure taking a String and an Integer argument
    
    [Date, Date], Duration  -- signature of calculateAge (Date dateOfBirth, today): Duration
----

In the above, the construction `[Type, ...]` represents a type-tuple.

== Routine Calls

At the third level of representation are literal calls, for example, `_calculateAge_ ('1982-03-22', '2019-06-01')`, which calculates a person's age from his data of birth and a given date. In normal programming languages, any of the parameters may be any referenceable value-returning entity, i.e. any in-scope variable, other function call etc, exemplified by a call such as `_calculateAge_ ('1982-03-22', _today_())`, where `_today_()` is a function returning the date of today. The meta-type `BMM_ROUTINE_CALL` and its descendants `BMM_PROCEDURE_CALL` and `BMM_FUNCTION_CALL` allow such calls to be represented. 

Such calls are direct equivalents for expressions using basic mathematical operators and functions, on the usual basis that any operator (such as 'plus', i.e. `+`) is formally defined as a function such as `add (arg1, arg2: Numeric): Numeric`. Thus, the instance structure for a typical expression such as the Body Mass Index (BMI), i.e. `weight / height^2`, is shown below.

[.text-center]
.Function call example - Body Mass index (BMI)
image::{uml_diagrams_uri}/LANG-bmm-nested_call.svg[id=bmm_nested_call, align="center"]

The model of  `BMM_ROUTINE_CALL` allows not only simple calls with all arguments filled to be specified, but also calls with open arguments, for example, `format_structure (struct=?, style=3)` (the syntax of this will vary according to programming language). This facility allows the latter call to be supplied as an argument to another routine, where the argument type is `[Integer]` (assuming `struct` is of type `Integer`). This capability is known as {wikipedia_currying}[function currying^] and is the basis for enabling delayed routine calls to have their arguments progressively filled before final execution.

== Class Definitions

include::{uml_export_dir}/classes/bmm_signature.adoc[]
include::{uml_export_dir}/classes/bmm_routine_call.adoc[]
include::{uml_export_dir}/classes/bmm_function_call.adoc[]
include::{uml_export_dir}/classes/bmm_procedure_call.adoc[]
include::{uml_export_dir}/classes/bmm_tuple.adoc[]
include::{uml_export_dir}/classes/bmm_tuple_item.adoc[]
