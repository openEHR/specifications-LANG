= Expressions

== Overview

Expressions in BMM are used to specify class invariants, routine pre- and post-conditions, and may be used more generally in other contexts requiring expressions. They are defined by a set of classes prefixed by 'EL', indicating 'expression language'. The BMM expression meta-model is based on the following taxonomy of expression entities:

[.text-center]
.Expression Taxonomy
image::{diagrams_uri}/bmm_expression_taxonomy.svg[id=bmm_expression_taxonomy, align="center"]

The meta-types defined in this part of the BMM model may be understood as the types of entities in an abstract syntax tree (AST) generated from expression parsing. Conversely, one or more expression syntaxes may be parsed into a tree based on the model described here. Note however, that whatever the variation in surface syntax, all such syntaxes parsed this way ultimately have the semantics defined by the BMM EL meta-model described here. This is true even for expressions written in a syntax whose published semantics are in fact different, e.g. a well-known programming language.

The key abstract meta-types shown in the taxonomy are Simple (`EL_SIMPLE`), Complex (`EL_COMPLEX`) and under Simple, Terminal (`EL_TERMINAL`) and Predicate (`EL_PREDICATE`). The first split between Simple and Complex distinguishes 'simple' expressions that are either Terminals or classical operator trees of Terminals, from 'complex' constructs, such as those used to represent multi-way decision structures. The split between Terminal and Predicate distinguishes 'real' expression entities (the former), and meta-level predicates having a Terminal expression as a target. The Predicate meta-type is the parent of 'existence' and also path-based meta-expressions targetting instance entities (such as defined by Xpath etc).

The UML model of the BMM `expression` package, consisting of mostly direct equivalents of the taxonomy classes above, is shown below. 

[.text-center]
.`bmm.expression` Package
image::{uml_diagrams_uri}/LANG-bmm.expression.svg[id=bmm_expression, align="center"]

Most `EL` classes are descendants of the class `EL_EXPRESSION`, which is characterised by the feature `_eval_type()_`. This is the BMM meta-type of the _result type_ of the expression entity when used in an expression; for literals, this is the inferred type; for object references (including function calls), this is the same as the declared type, and for agents it is the meta-type `BMM_SIGNATURE`.

== Terminal Entities

The underlying semantic concept of expressions in BMM, as for any language, is of a construct that refers to _instantiated model entities_ and which _generates values when evaluated_ at execution time. The notion of a _reference_ is fundamentally different from a _definition_, which is the concern of the rest of the meta-model, in that it operates at the instance level rather than at the type level. The primitive elements of a BMM expression may take the form of any of the following:

* _literal values_: inline-generated values created without reference to a model instance, but which must be instances of types defined by the model (`EL_LITERAL`);
* _model-based references_: (`EL_SCOPED_REF`)
** _references to instances_: symbolic references to instance values stored (as properties or variables) within the current or another object scope (`EL_INSTANTIABLE_REF<T>`);
** _calls to functions_: appropriately constructed calls to functions of the types that define instances (`EL_FUNCTION_CALL`);
** _generation of agents_: a special kind of reference to any routine of a model type that generates a _delayed routine call object_ (`EL_AGENT`).

Generally speaking, the latter two categories - function calls and delayed routine calls - will involve literal values and instance references where call arguments are stated. Consequently, the value generated by an expression is founded upon literal values and instance references. To be valid, any model-based reference must have a scoping object, which is one of:

* the 'current' object, within which the expression is situated and being evaluated;
* another object, which may be designated via:
** a specified scoping object, usually achieved through 'dot-notation' in most languages;
** an anonymous object representing a type;
* a type, for which no instance is created, on which argumentless function calls and constants may be accessed.

The notion of scoping object is supported via the attribute `_scope_` defined in `EL_SCOPED_REF`.

In addition, one other category of primitive expression element is supported:

* _predicates_: Boolean-generating expression elements formed by built-in predicates applied to any of the other value-generating expression elements.

The model described in this section supports these primitive elements via descendants of the `EL_TERMINAL` meta-type. For ease of comprehension, the following UML diagram provides an annotated view of these  meta-types.

[.text-center]
.bmm.expression Package - Type hierarchy
image::{uml_diagrams_uri}/LANG-bmm.expression-type_hierarchy.svg[id=bmm_expression_type_hierarchy, align="center"]

=== Literals

A literal value may appear in an expression as a separate entity within an operator expression, as well as a functional call or agent parameter. The literal values that may be used are either instances of the {openehr_foundation_types}[openEHR Foundation Types^] in {openehr_odin}#_leaf_data[ODIN format^], or a complex object instance in structured serial format, specified by `BMM_SERIAL_FORMALISM` if not a primitive type.

=== Tuples

Although rarely useful in class definitions, a Tuple of any degree may be formed from any combination of other EL expressions and used on its own as an expression terminal element. The main use for this construct is to express a literal tuple, i.e. one whose constituents consist only of proper literal values.

For more general uses of BMM Expressions, tuple instances are the basis of representing ad hoc query results which have a formal type such as `List<[T~a~, T~b~, T~c~]>`, where `[T~a~, T~b~, T~c~]` represents a tuple of three types.

=== Feature References

In BMM, a _feature reference_ is any symbolic reference to a class feature or variable that resolves to an object at evaluation time. This includes all referenceable entities within classes except procedures, which have no return value. Concretely, a feature reference takes the form of one of:

* a property name, e.g. `_name_`;
* a constant name, e.g. `_pi_`;
* a variable or parameter name, e.g. `_a_name_`, `_call_name_`;
* a function call.

Function calls are described in detail in the following section.

=== Self Reference

A special meta-type, `EL_SELF_REF` is provided for references to the current scoping object for any expressions in which it appears. An instance of this meta-class corresponds to references such as 'this' or 'self' found in object-oriented programming languages.

=== Type Reference

A special meta-type, `EL_TYPE_REF` is provided to refer to a type as an object. This is exclusively used as a convenient way (common in many programming languages) of accessing _class features_ that do not depend on instance properties (i.e. 'constant', 'enum', and 'static' members in C-based languages) without having to explicitly create an instance. As an expression, a type reference will normally only appear as a qualifier of a feature reference, using syntax such as `{TypeName}._feature_`, or with arguments, `{TypeName}._function (args...)_`.

A class feature is defined as one that is:

* a constant;
* an enumeration literal;
* a function that does not reference any class property or make any call that does, in its `_body_`, `_pre_conditions_` or `_post_conditions_`.

The last category typically includes 'external' functions that are wrappers for calls to the operating system or other external resource that maintains its own state independently.

Since a type reference can be made without instantiation, it may be made to an abstract class as well as a concrete one. This facilitates the use of so-called 'utility' classes containing groups of useful functions e.g. for handling specific kinds of strings.

Examples of type references as qualifiers of class features include the following:

* `{Env}._current_time_` to access the class function `_current_time_` defined on the class (or interface) `Env`;
* `{Colours}.red`, to access an enumeration literal;
* `{Version_utils}.version_higher ("1.5.40", "11.5.4")`.

A type reference may also be used on its own, such as in the following type test, which is the EL equivalent of programming language operators like `type_of()`.

* `admission_dates.type = {Interval<Iso8601_date_time>}`.

=== Agents

An agent is the BMM term for a delayed routine call, and has the meta-type `EL_AGENT`, which in turn has as its formal evaluation type (`_eval_type_`) is the meta-type `BMM_SIGNATURE`. It usually appears as a standalone expression, or else a parameter within another agent or function call. Agents are described in detail in the following section.

=== Predicates

Predicates in BMM are Boolean-returning terminal expressions taking one feature reference operand, and are represented by the meta-type `EL_PREDICATE`. Predicates conceptually apply to data instance structures and may be understood as queries on data. Any number of specific predicates might be added as extensions via inheritance. In particular, Xpath-style predicates could be supported by addition of meta-types descending from `EL_PREDICATE`.

The following predicates are pre-defined.

==== Attached (x)

The `attached` predicate is used to test for an instance reference (including a function call result) being `Void`. It may be used in expressions such as the following class invariant.

[source,kotlin]
----
class SmartRef

feature

    property url: Url;
    property value: Base64String;
    
    invariant
        Validity: attached(url) or attached(value)
----

==== Defined (x)

The `defined` predicate is used to test whether an instance that is mapped to an external data access method exists in the data context (regardless of its value there).

[.tbd]
TBD: this might be replaced by another approach.

== Constrained Expressions

In some cases there is a need to define a constrained form of an existing expression meta-type, such that the constraint can be conveniently asserted in other contexts. The meta-class `EL_CONSTRAINED` is provided for this purpose. It has an attribute `_base_expression_` referring to the underlying expression meta-type to be constrained. Any descendant of `EL_CONSTRAINED` may then be defined in order to add specific type or other constraints. One commonly used meta-type, `EL_BOOLEAN_EXPRESSION`, is defined, which constrains the base expression to being one whose evaluation type (`_eval_type_`) is `Boolean`.

== Operator Expressions

BMM contains meta-types representing operators, but assumes that all operators are surface aliases for functions defined on some class. For this reason, an occurrence of an operator within an expression, represented an instance of a descendant of `EL_OPERATOR`, contains the attribute `_definition_` to refer to the corresponding function definition. This has to be inferred from the types of its operands. Consequently, 'operator expressions' as commonly understood are simply function calls (often nested) in BMM. The following example illustrates the general meta-model of expressions, using a typical use of expression, the class invariant.

[source, kotlin]
----
class Account

feature
    balance: Decimal
    overdraft_limit: Decimal

invariant
    balance + overdraft_limit > 0
----

The expression `balance + overdraft_limit > 0` makes use of two operators `+ and `>`, which are really functions defined on the type `Decimal`, as follows.

[source, kotlin]
----
class Decimal

feature
    greater_than (other: Decimal): Boolean
        alias '>'

    addition: (other: Decimal): Decimal
        alias '+'
----

A parser processing this expression would produce the result shown below, assuming that the BMM model containing these classes had already been instantiated.

[.text-center]
.Instantiated Operator Expression
image::{diagrams_uri}/bmm_expression_property_ref.svg[id=bmm_expression_property_ref, align="center"]

Below, we consider a number of examples illustrating expressions containing the various kinds of terminal reference, based on the following assumed declarations.

[source, kotlin]
----
    feature -- Definitions
    
        Fast_resting_heart_rate: Real = 100;
        Atrial_fibrillation_heart_rate: Real = 120;
        Erratic: Terminology_code = {
            "terminology_id": "snomed_ct",
            "code_string": "286761003"
        }
        Blood_pressure_units: String = "mm[Hg]";
    
    feature -- Accessors
    
        heart_rate: Real;
        heart_rhythm: Terminology_code;    
        bp_samples: List<Quantity>;
        patient: Patient;
----

The first example is a comparison of a property value to a value, where the `>=` operator maps to the function `Real._greater_than_or_equal_()`

[source, kotlin]
----
    heart_rate >= 80
----

The following shows the comparison of a property value with a constant, where the `>=` operator maps to the function `Real._greater_than_or_equal_()`

[source, kotlin]
----
    heart_rate >= Fast_resting_heart_rate
----

The following is a logical condition, where the `=` operator maps to a function such as `Terminology_code._equal_()`; `and` maps to `Boolean._and_()`; and `>=` maps to `Real._greater_than_or_equal_()`.

[source, kotlin]
----
    heart_rhythm = Erratic and heart_rate >= Atrial_fibrillation_heart_rate
----

The following is the same logical condition, but with the use of object scope specified with 'dot notation', here `'patient.'`.

[source, kotlin]
----
    patient.heart_rhythm = Erratic and patient.heart_rate >= Atrial_fibrillation_heart_rate
----

The following shows a function call whose argument is an expression.

[source, kotlin]
----
    date_of_birth.earlier ({Env}.current_date - P10Y)
----

The following shows the use of an inline agent as an argument to the function `List._for_all_()`.

[source, kotlin]
----
    bp_samples.for_all (
        agent (a_quantity: Quantity) {
            a_quantity.units.is_equal (Blood_pressure_units);
        }
    );
----

== Decision Tables

The BMM `expression` package contains the meta-class `EL_DECISION_TABLE` that defines an abstract _decision table_ construct, consisting of an ordered set of `_items_`, each of type `EL_DECISION_BRANCH`, and having a `_result_` of any expression type (including another decision table). Two concrete subtypes of each of these abstract meta-types are used to represent two common kinds of decision table: 

* an if/then/elseif/else condition chain (meta-classes `EL_CONDITION_CHAIN` and `EL_CONDITIONAL_EXPRESSION`); and
* a case statement style table (meta-classes `EL_CASE_TABLE` and `EL_CASE`), whose conditions are value intervals against which the table's `_input_` value expression is evaluated to determine the result.

The `_else_` branch will be used to provide the result expression in the case that all other branches fail, guaranteeing a result. 

`EL_DECISION_TABLE` and its descendants are also kind of expression, enabling them to be used as value-returning entities in certain other expression contexts, including inside other decision tables.

The following UML illustrates. 

[.text-center]
.bmm.expression Decision Table
image::{uml_diagrams_uri}/LANG-bmm.expression-decision_table.svg[id=bmm_expression_decision_table, align="center"]

The logic of a `EL_CONDITION_CHAIN` is the same as an if/then/elseif/else chain in procedural programming, except that instead of assignment statements on each branch, pure result expressions are used. This enables a more sophisticated syntactic rendering, resembling a table, such as the following:

[source, kotlin]
----
    molecular_subtype: Terminology_term
        Result := choice in
            =========================================================
            er_positive and 
            her2_negative and 
            not ki67.in_range ([high]):    [luminal_A],
            ---------------------------------------------------------
            er_positive and 
            her2_negative and 
            ki67.in_range ([high]):        [luminal_B_HER2_negative],
            ---------------------------------------------------------
            er_positive and 
            her2_positive:                 [luminal_B_HER2_positive],
            ---------------------------------------------------------
            er_negative and 
            pr_negative and 
            her2_positive and 
            ki67.in_range ([high]):        [HER2],
            ---------------------------------------------------------
            er_negative and
            pr_negative and 
            her2_negative and 
            ki67.in_range ([high]):        [triple_negative],
            ---------------------------------------------------------
            *:                             [none]
            =========================================================
        ;
----

The above is a function that computes the molecular subtype of breast cancer using a decision table whose branches are based on a number of input variables that appear in expressions down the left-hand side and which returns a `Terminology_code` instance (the notation `[identifier]` is represents a literal `Terminology_code` instance).

An example of `EL_CASE_TABLE` is shown below. Here, two case tables are used, with each generating a numeric result based on the values of the `platelets` and `gfr` variables respectively.

[source, kotlin]
----
    cyclophosphamide_dose: Quantity
        Result := cyclophosphamide_dose_per_m2 * BSA.bsa_m2
            * case platelets.range in 
                ===================
                [normal]:      1,
                [low]:         0.75
                ===================
            * case gfr.range in
                ===================
                [normal]:      1,
                [low]:         0.75,
                [very_low]:    0.5
                ===================
            ;
----

== Usage in BMM Models

Expressions as used in BMM models to express class invariants and routine pre- and post-conditions are always in the form of an `BMM_ASSERTION`, i.e. a tagged Boolean-returning `EL_EXPRESSION`.

=== Simple Assertions

Simple assertions may be formed from common operators and operands, including the usual logical arithmetic and comparison operators, as well as any operators relating to specific data types. Normally the top-level operator in the Expression graph is a logical or relational operator. Since all operators are mapped to functions defined on types, there are no 'floating' or 'built-in' operators as such.

=== Existential and Universal Quantifier Invariants

A common kind of expression used in class invariants operates over collections and uses the existential and universal quantifier operators, i.e. ∃ and ∀, from predicate logic. A typical expression to use within a class invariant is shown below in an abstract syntax.

[source,kotlin]
----
class PersonName
property items: String[1..*];

invariant
    ∀ nameItem: items | not nameItem.isEmpty()
----

A different syntax might express it as follows.

[source,kotlin]
----
    invariant
        for nameItem in items all 
            not nameItem.isEmpty() 
        end
----

A similar invariant, this time using ∃, is shown below.

[source,kotlin]
----
    invariant
        for nameItem in items 
            ∃ not nameItem.isEmpty()
----

Regardless of the surface syntax, expressions such as the above map to functions such as `_for_all_` and `there_exists` defined on relevant linear container types. These functions have the following signatures in which the 'test' expression appears as a Function agent type.

[source,kotlin]
----
class Container<T>

feature

    for_all (test: Function<[T], Boolean>): Boolean;
            -- True if for every v in container, test (v) is True    

    there_exists (test: Function<[T], Boolean>): Boolean;
            -- True if there is any v in container for which test (v) is True
----

== Class Definitions

include::{uml_export_dir}/classes/el_expression.adoc[]
include::{uml_export_dir}/classes/el_constrained.adoc[]
include::{uml_export_dir}/classes/el_boolean_expression.adoc[]

include::{uml_export_dir}/classes/el_operator.adoc[]
include::{uml_export_dir}/classes/el_unary_operator.adoc[]
include::{uml_export_dir}/classes/el_binary_operator.adoc[]

include::{uml_export_dir}/classes/el_simple.adoc[]
include::{uml_export_dir}/classes/el_terminal.adoc[]

include::{uml_export_dir}/classes/el_predicate.adoc[]
include::{uml_export_dir}/classes/el_defined.adoc[]
include::{uml_export_dir}/classes/el_attached.adoc[]

include::{uml_export_dir}/classes/el_instance_ref.adoc[]

include::{uml_export_dir}/classes/el_self_ref.adoc[]
include::{uml_export_dir}/classes/el_type_ref.adoc[]
include::{uml_export_dir}/classes/el_literal.adoc[]

include::{uml_export_dir}/classes/el_scoped_ref.adoc[]
include::{uml_export_dir}/classes/el_instantiable_ref.adoc[]
include::{uml_export_dir}/classes/el_agent_call.adoc[]
include::{uml_export_dir}/classes/el_function_call.adoc[]

include::{uml_export_dir}/classes/el_agent.adoc[]
include::{uml_export_dir}/classes/el_function_agent.adoc[]
include::{uml_export_dir}/classes/el_procedure_agent.adoc[]

include::{uml_export_dir}/classes/el_tuple.adoc[]
include::{uml_export_dir}/classes/el_tuple_item.adoc[]

include::{uml_export_dir}/classes/el_decision_table.adoc[]
include::{uml_export_dir}/classes/el_decision_branch.adoc[]

include::{uml_export_dir}/classes/el_condition_chain.adoc[]
include::{uml_export_dir}/classes/el_conditional_expression.adoc[]

include::{uml_export_dir}/classes/el_case_table.adoc[]
include::{uml_export_dir}/classes/el_case.adoc[]
