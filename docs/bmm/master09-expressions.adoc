= Expressions

== Overview

Expressions in BMM are used to specify class invariants, routine pre- and post-conditions, and may be used more generally in other contexts requiring expressions. They are defined by a set of classes prefixed by 'EL', indicating 'expression language'. The BMM expression meta-model is based on the following taxonomy of expression entities:

[.text-center]
.Expression Taxonomy
image::{diagrams_uri}/bmm_expression_taxonomy.svg[id=bmm_expression_taxonomy, align="center"]

The meta-types defined in this part of the BMM model may be understood as the types of entities in an abstract syntax tree (AST) generated from expression parsing. Conversely, one or more expression syntaxes may be parsed into a tree based on the model described here. Note however, that whatever the variation in surface syntax, all such syntaxes parsed this way ultimately have the semantics defined by the BMM EL meta-model. This is true even for expressions written in a syntax whose published semantics are in fact different, e.g. a well-known programming language.

The UML model of the BMM `expression` package, consisting of mostly direct equivalents of the taxonomy classes above, is shown below. 

[.text-center]
.`bmm.expression` Package
image::{uml_diagrams_uri}/LANG-bmm.expression.svg[id=bmm_expression, align="center"]

`EL` classes are descendants of the class `EL_EXPRESSION`, which is characterised by the feature `_eval_type()_`. This is the BMM meta-type of the _result type_ of the expression entity when used in an expression; for literals, this is the inferred type; for object references (including function calls), this is the same as the declared type, and for agents it is the meta-type `BMM_SIGNATURE`.

Most `EL_EXPRESSIONs` are either value generating constructs (`EL_VALUE_GENERATOR`) or operator expressions. The special sub-type `E_TUPLE` represents tuple objects which are created on the fly by inline expressions of the form `[expr, expr, ...]`.

== Terminal Entities

Terminal entities are atomic with respect to operator expressions, and are either _simple_ entities of familiar kinds (function calls, variable references etc) or complex logic structures that when evaluated generate a value.

=== Simple Entities

The simple terminal meta-types in EL are as follows:

* _literal values_: inline-generated values created without reference to a model instance, but which must be instances of types defined by the model (`EL_LITERAL`);
* _value references_ (`EL_VALUE_REF`) based on formal model elements that are (potentially) attached to an instance at runtime;
* _predicates_: Boolean-generating expression elements formed by predicates applied to any of the other value-generating expression elements.

The model described in this section supports these primitive elements via descendants of the `EL_SIMPLE` meta-type. For ease of comprehension, the following UML diagram provides an annotated view of these meta-types.

[.text-center]
.bmm.expression Package - Type hierarchy
image::{uml_diagrams_uri}/LANG-bmm.expression-type_hierarchy.svg[id=bmm_expression_type_hierarchy, align="center"]

==== Literals

A literal value may appear as a separate entity within an operator expression, as well as a functional call or agent parameter. The literal values that may be used are either instances of the {openehr_foundation_types}[openEHR Foundation Types^] or a complex object instance in a structured serial format (such as JSON, a JSON derivative, {openehr_odin}#_leaf_data[ODIN format^] etc), specified by `BMM_LITERAL_VALUE.syntax`.

==== Value References

References are categorised as follows:

* _model-based references_: (`EL_SCOPED_REF`);
** _references to instances_: symbolic references to instance values stored (as properties or variables) within the current or another object scope (`EL_INSTANTIABLE_REF`);
** _calls to functions_: appropriately constructed calls to functions of the types that define instances (`EL_FUNCTION_CALL`);
** _generation of agents_: a special kind of reference to any routine of a model type that generates a _delayed routine call object_ (`EL_AGENT`);
* _self reference_: (`EL_SELF_REF`) the 'current' object, within which the expression is situated and being evaluated;
* _a type reference_: (`EL_TYPE_REF`) a reference representing a type object assumed to be available at runtime, on which argumentless function calls and constants may be accessed.

The arguments of function calls and delayed routine calls may be complex expressions, but will eventually resolved to literal values and instance references. Consequently, the value generated by any expression is ultimately founded upon literal values and instance references.

To be valid, any model-based feature reference must have a scoping object (represented via the attribute `_scope_` in `EL_SCOPED_REF`), which is one of:

* the current object - implied;
* another object, which may be designated via:
** a specified scoping object, achieved through 'dot-notation' in most languages;
** a type reference.

===== Feature References

In BMM, a _feature reference_ is any symbolic reference to a class feature that resolves to an object at evaluation time. This includes all referenceable entities within classes except procedures, which have no return value. Concretely, a feature reference takes the form of one of:

* a property name, e.g. `_name_`;
* a constant name, e.g. `_pi_`;
* a variable or parameter name, e.g. `_a_name_`, `_call_name_`;
* a function call.

Function calls are described in detail in the following section.

===== Type Reference

A special meta-type, `EL_TYPE_REF` is provided to refer to a type as an object. This is exclusively used as a convenient way (common in many programming languages) of accessing _class features_ that do not depend on instance properties (i.e. 'constant', 'enum', and 'static' members in C-based languages) without having to explicitly create an instance. As an expression, a type reference will normally only appear as a qualifier of a feature reference, using syntax such as `{TypeName}._feature_`, or with arguments, `{TypeName}._function (args...)_`.

A class feature is defined as one that is:

* a constant;
* an enumeration literal;
* a function that does not reference any class property or make any call that does, in its `_body_`, `_pre_conditions_` or `_post_conditions_`.

The last category typically includes 'external' functions that are wrappers for calls to the operating system or other external resource that maintains its own state independently.

Since a type reference can be made without instantiation, it may be made to an abstract class as well as a concrete one. This facilitates the use of so-called 'utility' classes containing groups of useful functions e.g. for handling specific kinds of strings.

Examples of type references as qualifiers of class features include the following:

* `{Env}._current_time_` to access the class function `_current_time_` defined on the class (or interface) `Env`;
* `{Colours}.red`, to access an enumeration literal;
* `{Version_utils}.version_higher ("1.5.40", "11.5.4")`.

A type reference may also be used on its own, such as in the following type test, which is the EL equivalent of programming language operators like `type_of()`.

* `admission_dates.type = {Interval<Iso8601_date_time>}`.

===== Agents

An agent is the BMM term for a delayed routine call, and has the meta-type `EL_AGENT`, which in turn has as its formal evaluation type (`_eval_type_`) is the meta-type `BMM_SIGNATURE`. It usually appears as a standalone expression, or else a parameter within another agent or function call. Agents are described in detail in the following section.

==== Variable References

Variable references are one of the following:

* variables declared locally in a routine (meta-type `EL_VARIABLE_REF` with `definition` = `BMM_LOCAL`);
* named arguments of a routine (meta-type `EL_VARIABLE_REF` with `definition` = `BMM_PARAMETER`);
* a special variable called 'Result' representing the result object of a function (meta-type `EL_VARIABLE_REF` with `definition` = `BMM_result`);
* a special variable (often called 'this' or 'self' in object-oriented programming languages) to refer to the object acting as the context for enclosed statements (`EL_SELF_REF` meta-type).

==== Predicates

Predicates in BMM are Boolean-returning terminal expressions taking one feature reference operand, and are represented by the meta-type `EL_PREDICATE`. Predicates conceptually apply to data instance structures and may be understood as queries on data. Any number of specific predicates might be added as extensions via inheritance. In particular, Xpath-style predicates could be supported by addition of meta-types descending from `EL_PREDICATE`. The following UML shows the predicate meta-types.

[.text-center]
.Predicates
image::{uml_diagrams_uri}/LANG-bmm.expression-predicate.svg[id=bmm_expression_predicate, align="center"]

The following predicates are pre-defined.

===== Attached (x)

The `attached` predicate is used to test for an instance reference (including a function call result) being `Void`. It may be used in expressions such as the following class invariant.

[source,kotlin]
----
class SmartRef

feature

    property url: Url;
    property value: Base64String;
    
    invariant
        Validity: attached(url) or attached(value)
----

===== Defined (x)

The `defined` predicate is used to test whether an instance that is mapped to an external data access method exists in the data context (regardless of its value there).

[.tbd]
TBD: this might be replaced by another approach.

=== Decision Tables

The BMM `expression` package contains the meta-class `EL_DECISION_TABLE` that defines an abstract _decision table_ construct, consisting of an ordered set of `_items_`, each of type `EL_DECISION_BRANCH`, and having a `_result_` of any expression type (including another decision table). Two concrete subtypes of each of these abstract meta-types are used to represent two common kinds of decision structure found in procedural and most object-oriented programming languages: 

* an if/then/elseif/else condition chain (meta-classes `EL_CONDITION_CHAIN` and `EL_CONDITIONAL_EXPRESSION`); and
* a case statement style table (meta-classes `EL_CASE_TABLE` and `EL_CASE`), whose conditions are value intervals against which the table's `_input_` value expression is evaluated to determine the result.

The `_else_` branch will be used to provide the result expression in the case that all other branches fail, guaranteeing a result. 

`EL_DECISION_TABLE` and its descendants are also kind of expression, enabling them to be used as value-returning entities in certain other expression contexts, including inside other decision tables.

The following UML illustrates. 

[.text-center]
.Decision Tables
image::{uml_diagrams_uri}/LANG-bmm.expression-decision_table.svg[id=bmm_expression_decision_table, align="center"]

The logic of a `EL_CONDITION_CHAIN` is the same as an if/then/elseif/else chain in procedural programming, except that instead of assignment statements on each branch, pure result expressions are used. This enables a more sophisticated syntactic rendering, resembling a table, such as the following:

[source, kotlin]
----
    molecular_subtype: Terminology_term
        Result := choice in
            =======================================================
            er_positive and 
            her2_negative and 
            not ki67.in_range (#high):    #luminal_A,
            -------------------------------------------------------
            er_positive and 
            her2_negative and 
            ki67.in_range (#high):        #luminal_B_HER2_negative,
            -------------------------------------------------------
            er_positive and 
            her2_positive:                #luminal_B_HER2_positive,
            -------------------------------------------------------
            er_negative and 
            pr_negative and 
            her2_positive and 
            ki67.in_range (#high):        #HER2,
            -------------------------------------------------------
            er_negative and
            pr_negative and 
            her2_negative and 
            ki67.in_range (#high):        #triple_negative,
            -------------------------------------------------------
            *:                            #none
            =======================================================
        ;
----

The above is a function that computes the molecular subtype of breast cancer using a decision table whose branches are based on a number of input variables that appear in expressions down the left-hand side and which returns a `Terminology_code` instance (the notation `#identifier` represents a literal `Terminology_code` instance).

An example of `EL_CASE_TABLE` is shown below. Here, two case tables are used, with each generating a numeric result based on the values of the `platelets` and `gfr` variables respectively.

[source, kotlin]
----
    cyclophosphamide_dose: Quantity
        Result := cyclophosphamide_dose_per_m2 * BSA.bsa_m2
            * case platelets.range in 
                ===================
                #normal:      1,
                #low:         0.75
                ===================
            * case gfr.range in
                ===================
                #normal:      1,
                #low:         0.75,
                #very_low:    0.5
                ===================
            ;
----

== Operator Expressions

BMM contains meta-types representing operators, but assumes that all operators are surface aliases for functions defined on some class. For this reason, an occurrence of an operator within an expression, represented an instance of a descendant of `EL_OPERATOR`, contains the attribute `_definition_` to refer to the corresponding function definition. This has to be inferred from the types of its operands. Consequently, 'operator expressions' as commonly understood are simply function calls (often nested) in BMM. The following UML shows the relevant meta-types.

[.text-center]
.Operator meta-types
image::{uml_diagrams_uri}/LANG-bmm.expression-operator.svg[id=bmm_expression_operator, align="center"]

The following example illustrates the general meta-model of expressions, using a typical use of expression, the class invariant.

[source, kotlin]
----
class Account

feature
    balance: Decimal
    overdraft_limit: Decimal

invariant
    balance + overdraft_limit > 0
----

The expression `balance + overdraft_limit > 0` makes use of two operators `+` and `>`, which are really functions defined on the type `Decimal`, as follows.

[source, kotlin]
----
class Decimal

feature
    greater_than (other: Decimal): Boolean
        alias '>'

    addition: (other: Decimal): Decimal
        alias '+'
----

A parser processing this expression would produce the result shown below, assuming that the BMM model containing these classes had already been instantiated.

[.text-center]
.Instantiated Operator Expression
image::{diagrams_uri}/bmm_expression_property_ref.svg[id=bmm_expression_property_ref, align="center"]

Below, we consider a number of examples illustrating expressions containing the various kinds of terminal reference, based on the following assumed declarations.

[source, kotlin]
----
    feature -- Definitions
    
        Fast_resting_heart_rate: Real = 100;
        Atrial_fibrillation_heart_rate: Real = 120;
        Erratic: Terminology_code = {
            "terminology_id": "snomed_ct",
            "code_string": "286761003"
        }
        Blood_pressure_units: String = "mm[Hg]";
    
    feature -- Accessors
    
        heart_rate: Real;
        heart_rhythm: Terminology_code;    
        bp_samples: List<Quantity>;
        patient: Patient;
----

The first example is a comparison of a property value to a value, where the `>=` operator maps to the function `Real._greater_than_or_equal_()`

[source, kotlin]
----
    heart_rate >= 80
----

The following shows the comparison of a property value with a constant, where the `>=` operator maps to the function `Real._greater_than_or_equal_()`

[source, kotlin]
----
    heart_rate >= Fast_resting_heart_rate
----

The following is a logical condition, where the `=` operator maps to a function such as `Terminology_code._equal_()`; `and` maps to `Boolean._and_()`; and `>=` maps to `Real._greater_than_or_equal_()`.

[source, kotlin]
----
    heart_rhythm = Erratic and heart_rate >= Atrial_fibrillation_heart_rate
----

The following is the same logical condition, but with the use of object scope specified with 'dot notation', here `'patient.'`.

[source, kotlin]
----
    patient.heart_rhythm = Erratic and patient.heart_rate >= Atrial_fibrillation_heart_rate
----

The following shows a function call whose argument is an expression.

[source, kotlin]
----
    date_of_birth.earlier ({Env}.current_date - P10Y)
----

The following shows the use of an inline agent as an argument to the function `List._for_all_()`.

[source, kotlin]
----
    bp_samples.for_all (
        agent (a_quantity: Quantity) {
            a_quantity.units.is_equal (Blood_pressure_units);
        }
    );
----

== Tuples

Although rarely useful in class definitions, a Tuple of any degree may be formed from any combination of other EL expressions and used on its own as an expression terminal element. The main use for this construct is to express a literal tuple, i.e. one whose constituents consist only of proper literal values.

For more general uses of BMM Expressions, tuple instances are the basis of representing ad hoc query results which have a formal type such as `List<[T~a~, T~b~, T~c~]>`, where `[T~a~, T~b~, T~c~]` represents a tuple of three types.

== Usage in BMM Models

Expressions as used in BMM models to express class invariants and routine pre- and post-conditions are always in the form of an `BMM_ASSERTION`, i.e. a tagged Boolean-returning `EL_EXPRESSION`.

=== Simple Assertions

Simple assertions may be formed from common operators and operands, including the usual logical arithmetic and comparison operators, as well as any operators relating to specific data types. Normally the top-level operator in the Expression graph is a logical or relational operator. Since all operators are mapped to functions defined on types, there are no 'floating' or 'built-in' operators as such.

=== Existential and Universal Quantifier Invariants

A common kind of expression used in class invariants operates over collections and uses the existential and universal quantifier operators, i.e. ∃ and ∀, from predicate logic. A typical expression to use within a class invariant is shown below in an abstract syntax.

[source,kotlin]
----
class PersonName
property items: String[1..*];

invariant
    ∀ nameItem: items | not nameItem.isEmpty()
----

A different syntax might express it as follows.

[source,kotlin]
----
    invariant
        for nameItem in items all 
            not nameItem.isEmpty() 
        end
----

A similar invariant, this time using ∃, is shown below.

[source,kotlin]
----
    invariant
        for nameItem in items 
            ∃ not nameItem.isEmpty()
----

Regardless of the surface syntax, expressions such as the above map to functions such as `_for_all_` and `there_exists` defined on relevant linear container types. These functions have the following signatures in which the 'test' expression appears as a Function agent type.

[source,kotlin]
----
class Container<T>

feature

    for_all (test: Function<[T], Boolean>): Boolean;
            -- True if for every v in container, test (v) is True    

    there_exists (test: Function<[T], Boolean>): Boolean;
            -- True if there is any v in container for which test (v) is True
----

== Class Definitions

include::{uml_export_dir}/classes/el_expression.adoc[]

include::{uml_export_dir}/classes/el_terminal.adoc[]

include::{uml_export_dir}/classes/el_simple.adoc[]
include::{uml_export_dir}/classes/el_value_ref.adoc[]

include::{uml_export_dir}/classes/el_self_ref.adoc[]
include::{uml_export_dir}/classes/el_type_ref.adoc[]
include::{uml_export_dir}/classes/el_literal.adoc[]

include::{uml_export_dir}/classes/el_scoped_ref.adoc[]
include::{uml_export_dir}/classes/el_instantiable_ref.adoc[]
include::{uml_export_dir}/classes/el_variable_ref.adoc[]
include::{uml_export_dir}/classes/el_instantiable_feature_ref.adoc[]

include::{uml_export_dir}/classes/el_agent_call.adoc[]
include::{uml_export_dir}/classes/el_function_call.adoc[]

include::{uml_export_dir}/classes/el_agent.adoc[]
include::{uml_export_dir}/classes/el_function_agent.adoc[]
include::{uml_export_dir}/classes/el_procedure_agent.adoc[]

include::{uml_export_dir}/classes/el_predicate.adoc[]
include::{uml_export_dir}/classes/el_defined.adoc[]
include::{uml_export_dir}/classes/el_attached.adoc[]

include::{uml_export_dir}/classes/el_decision_table.adoc[]
include::{uml_export_dir}/classes/el_decision_branch.adoc[]

include::{uml_export_dir}/classes/el_condition_chain.adoc[]
include::{uml_export_dir}/classes/el_conditional_expression.adoc[]

include::{uml_export_dir}/classes/el_case_table.adoc[]
include::{uml_export_dir}/classes/el_case.adoc[]

include::{uml_export_dir}/classes/el_operator.adoc[]
include::{uml_export_dir}/classes/el_unary_operator.adoc[]
include::{uml_export_dir}/classes/el_binary_operator.adoc[]

include::{uml_export_dir}/classes/el_tuple.adoc[]
include::{uml_export_dir}/classes/el_tuple_item.adoc[]

include::{uml_export_dir}/classes/el_constrained.adoc[]
include::{uml_export_dir}/classes/el_boolean_expression.adoc[]

