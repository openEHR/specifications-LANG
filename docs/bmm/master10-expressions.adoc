= Expressions

== Overview

Expressions in BMM are used to specify class invariants, routine pre- and post-conditions, and may be used more generally in other contexts requiring expressions. They are defined by a set of classes prefixed by 'EL', indicating 'expression language'. The BMM expression meta-model supports the representation of the following:

* classical expressions using unary and binary operators with functional equivalents;
* terminal elements, including:
** literals;
** tuples containing items of any meta-type and concrete type;
** references to instantiable entities, i.e. object properties and routine variables;
** function calls;
** agents, i.e. delayed routine calls with possibly open parameters;
** predicates on other terminal entities, including 'attached' test for Void (null) instance values.

The meta-types defined in this part of the model may be understood as the types of entities in a parse tree or syntax tree (AST). Conversely, one or more expression syntaxes may be parsed into a tree based on the model described here. Note however, that whatever the variation in surface syntax, all such syntaxes parsed this way ultimately have the semantics defined by the BMM-EL meta-model. This is true even for expressions written in a syntax whose published semantics are in fact different, e.g. a well-known programming language.

The UML model of the BMM `expression` package is shown below. 

[.text-center]
.bmm.expression Package
image::{uml_diagrams_uri}/LANG-bmm.expression.svg[id=bmm_expression, align="center"]

Most `EL` classes are descendants of the class `EL_EXPRESSION`, which is characterised by the feature `_eval_type()_`. This is the BMM meta-type of the _result type_ of the expression entity when used in an expression; for literals, this is the inferred type; for object references (including function calls), this is the same as the declared type, and for agents it is the meta-type `BMM_SIGNATURE`.

== Semantics

=== Terminal Entities

The underlying semantic concept of expressions in BMM, as for any language, is of a construct that refers to _instantiated model entities_ and which _generates values when evaluated_ at execution time. The notion of a _reference_ is fundamentally different from a _definition_, which is the concern of the rest of the meta-model, in that it operates at the instance level rather than at the type level. The primitive elements of a BMM expression may take the form of any of the following:

* _literal values_: inline-generated values created without reference to a model instance, but which must be instances of types defined by the model (`EL_LITERAL`);
* _model-based references_: (`EL_SCOPED_REF`)
** _references to instances_: symbolic references to instance values stored (as properties or variables) within the current or another object scope (`EL_INSTANTIABLE_REF<T>`);
** _calls to functions_: appropriately constructed calls to functions of the types that define instances (`EL_FUNCTION_CALL`);
** _generation of agents_: a special kind of reference to any routine of a model type that generates a _delayed routine call object_ (`EL_AGENT`).

Generally speaking, the latter two categories - function calls and delayed routine calls - will involve literal values and instance references where call arguments are stated. Consequently, the value generated by an expression is founded upon literal values and instance references. To be valid, any model-based reference must have a scoping object, which is one of:

* the 'current' object, within which the expression is situated and being evaluated;
* another object, which may be designated via:
** a specified scoping object, usually achieved through 'dot-notation' in most languages;
** an anonymous object representing a type;
* a type, for which no instance is created, on which argumentless function calls and constants may be accessed.

The notion of scoping object is supported via the attribute `_scope_` defined in `EL_SCOPED_REF`.

In addition, one other category of primitive expression element is supported:

* _predicates_: Boolean-generating expression elements formed by built-in predicates applied to any of the other value-generating expression elements.

The model described in this section supports these primitive elements via descendants of the `EL_TERMINAL` meta-type. For ease of comprehension, the following UML diagram provides an annotated view of these  meta-types.

[.text-center]
.bmm.expression Package - Type hierarchy
image::{uml_diagrams_uri}/LANG-bmm.expression-type_hierarchy.svg[id=bmm_expression_type_hierarchy, align="center"]

==== Literals

A literal value may appear in an expression as a separate entity within an operator expression, as well as a functional call or agent parameter. The literal values that may be used are either instances of the {openehr_foundation_types}[openEHR Foundation Types^] in {openehr_odin}#_leaf_data[ODIN format^], or a complex object instance in structured serial format, specified by `BMM_SERIAL_FORMALISM` if not a primitive type.

==== Tuples

Although rarely useful in class definitions, a Tuple of any degree may be formed from any combination of other EL expressions and used on its own as an expression terminal element. The main use for this construct is to express a literal tuple, i.e. one whose constituents consist only of proper literal values.

For more general uses of BMM Expressions, tuple instances are the basis of representing ad hoc query results which have a formal type such as `List<[T~a~, T~b~, T~c~]>`, where `[T~a~, T~b~, T~c~]` represents a tuple of three types.

==== Feature References

In BMM, a _feature reference_ is any symbolic reference to a class feature or variable that resolves to an object at evaluation time. This includes all referenceable entities within classes except procedures, which have no return value. Concretely, a feature reference takes the form of one of:

* a property name, e.g. `_name_`;
* a constant name, e.g. `_pi_`;
* a variable or parameter name, e.g. `_a_name_`, `_call_name_`;
* a function call.

Function calls are described in detail in the following section.

==== Self Reference

A special meta-type, `EL_SELF_REF` is provided for references to the current scoping object for any expressions in which it appears. An instance of this meta-class corresponds to references such as 'this' or 'self' found in object-oriented programming languages.

==== Type Reference

A special meta-type, `EL_TYPE_REF` is provided to refer to a type as an object. This is exclusively used as a convenient way (common in many programming languages) of accessing _class features_ that do not depend on instance properties (i.e. 'constant', 'enum', and 'static' members in C-based languages) without having to explicitly create an instance. As an expression, a type reference will normally only appear as a qualifier of a feature reference, using syntax such as `{TypeName}._feature_`, or with arguments, `{TypeName}._function (args...)_`.

A class feature is defined as one that is:

* a constant;
* an enumeration literal;
* a function that does not reference any class property or make any call that does, in its `_body_`, `_pre_conditions_` or `_post_conditions_`.

The last category typically includes 'external' functions that are wrappers for calls to the operating system or other external resource that maintains its own state independently.

Since a type reference can be made without instantiation, it may be made to an abstract class as well as a concrete one. This facilitates the use of so-called 'utility' classes containing groups of useful functions e.g. for handling specific kinds of strings.

Examples of type references as qualifiers of class features include the following:

* `{Env}._current_time_` to access the class function `_current_time_` defined on the class (or interface) `Env`;
* `{Colours}.red`, to access an enumeration literal;
* `{Version_utils}.version_higher ("1.5.40", "11.5.4")`.

A type reference may also be used on its own, such as in the following type test, which is the EL equivalent of programming language operators like `type_of()`.

* `admission_dates.type = {Interval<Iso8601_date_time>}`.

==== Agents

An agent is the BMM term for a delayed routine call, and has the meta-type `EL_AGENT`, which in turn has as its formal evaluation type (`_eval_type_`) is the meta-type `BMM_SIGNATURE`. It usually appears as a standalone expression, or else a parameter within another agent or function call. Agents are described in detail in the following section.

==== Predicates

Predicates in BMM are Boolean-returning terminal expressions taking one feature reference operand, and are represented by the meta-type `EL_PREDICATE`. Predicates conceptually apply to data instance structures and may be understood as queries on data. Any number of specific predicates might be added as extensions via inheritance. In particular, Xpath-style predicates could be supported by addition of meta-types descending from `EL_PREDICATE`.

The following predicates are pre-defined.

===== Attached (x)

The `attached` predicate is used to test for an instance reference (including a function call result) being `Void`. It may be used in expressions such as the following class invariant.

[source,typescript]
----
class SmartRef
{
    property url: Url;
    property value: Base64String;
    
    invariant
        Validity: attached(url) or attached(value)
}
----

===== Defined (x)

The `defined` predicate is used to test whether an instance that is mapped to an external data access method exists in the data context (regardless of its value there).

[.tbd]
TBD: this might be replaced by another approach.

=== Operator Expressions

BMM contains meta-types representing operators, but assumes that all operators are surface aliases for functions defined on some class. For this reason, an occurrence of an operator within an expression, represented by `EL_OPERATOR`, contains the attribute `_definition_` to refer to the corresponding function call. This  has to be inferred from the types of its operands.

A number of examples illustrate expressions containing the various kinds of terminal reference, based on the following assumed declarations.

[source, typescript]
----
    feature -- Definitions
    
        Fast_resting_heart_rate: Real = 100;
        Atrial_fibrillation_heart_rate: Real = 120;
        Erratic: Terminology_code = {
            "terminology_id": "snomed_ct",
            "code_string": "286761003"
        }
        Blood_pressure_units: String = "mm[Hg]";
    
    feature -- Accessors
    
        heart_rate: Real;
        heart_rhythm: Terminology_code;    
        bp_samples: List<Quantity>;
        patient: Patient;
----

The first example is a comparison of a property value to a value, where the `>=` operator maps to the function `Real._greater_than_or_equal_()`

[source, typescript]
----
    heart_rate >= 80
----

The following shows the comparison of a property value with a constant, where the `>=` operator maps to the function `Real._greater_than_or_equal_()`

[source, typescript]
----
    heart_rate >= Fast_resting_heart_rate
----

The following is a logical condition, where the `=` operator maps to a function such as `Terminology_code._equal_()`; `and` maps to `Boolean._and_()`; and `>=` maps to `Real._greater_than_or_equal_()`.

[source, typescript]
----
    heart_rhythm = Erratic and heart_rate >= Atrial_fibrillation_heart_rate
----

The following is the same logical condition, but with the use of object scope specified with 'dot notation', here `'patient.'`.

[source, typescript]
----
    patient.heart_rhythm = Erratic and patient.heart_rate >= Atrial_fibrillation_heart_rate
----

The following shows a function call whose argument is an expression.

[source, typescript]
----
    date_of_birth.earlier ({Env}.current_date - P10Y)
----

The following shows the use of an inline agent as an argument to the function `List._for_all_()`.

[source, typescript]
----
    bp_samples.for_all (
        agent (a_quantity: Quantity) {
            a_quantity.units.is_equal (Blood_pressure_units);
        }
    );
----

=== Constraint Expressions

One class, `EL_CONSTRAINT_EXPRESSION` is included as a hook for specialisation in other models. This class represents a constraint matching expression of the form `<expr> matches <constraint>`. The concrete representation of the constraint is not modelled here, and could be supplied by subtypes.

[.tbd]
TBD: it might also be supplied by the type `C_OBJECT` from the AOM.

== Usage in BMM Models

Expressions as used in BMM models to express class invariants and routine pre- and post-conditions are always in the form of an `ASSERTION`, i.e. a tagged Boolean-returning `EL_EXPRESSION`.

=== Simple Expressions

Simple assertions may be formed from common operators and operands, including the usual logical arithmetic and comparison operators, as well as any operators relating to specific data types. Normally the top-level operator in the Expression graph is a logical or relational operator. Since all operators are mapped to functions defined on types, there are no 'floating' or 'built-in' operators as such.

=== Existential and Universal Quantifier Expressions

A common kind of expression used in class invariants operates over collections and uses the existential and universal quantifier operators, i.e. ∃ and ∀, from predicate logic. A typical expression to use within a class invariant is shown below in an abstract syntax.

[source,typescript]
----
class PersonName {
    property items: String[1..*];
    
    invariant
        ∀ nameItem: items | not nameItem.isEmpty()
}
----

A different syntax might express it as follows.

[source,typescript]
----
    invariant
        for nameItem in items all 
            not nameItem.isEmpty() 
        end
----

A similar invariant, this time using ∃, is shown below.

[source,typescript]
----
    invariant
        for nameItem in items 
            ∃ not nameItem.isEmpty()
----

Regardless of the surface syntax, expressions such as the above map to functions such as `_for_all_` and `there_exists` defined on relevant linear container types. These functions have the following signatures in which the 'test' expression appears as a Function agent type.

[source,typescript]
----
class Container<T> {

    for_all (test: Function<[T], Boolean>): Boolean;
            -- True if for every v in container, test (v) is True    

    there_exists (test: Function<[T], Boolean>): Boolean;
            -- True if there is any v in container for which test (v) is True
}
----

== Class Descriptions

include::{uml_export_dir}/classes/el_expression.adoc[]
include::{uml_export_dir}/classes/el_assertion.adoc[]

include::{uml_export_dir}/classes/el_operator.adoc[]
include::{uml_export_dir}/classes/el_unary_operator.adoc[]
include::{uml_export_dir}/classes/el_binary_operator.adoc[]

include::{uml_export_dir}/classes/el_terminal.adoc[]

include::{uml_export_dir}/classes/el_predicate.adoc[]
include::{uml_export_dir}/classes/el_defined.adoc[]
include::{uml_export_dir}/classes/el_attached.adoc[]

include::{uml_export_dir}/classes/el_instance_ref.adoc[]

include::{uml_export_dir}/classes/el_self_ref.adoc[]
include::{uml_export_dir}/classes/el_type_ref.adoc[]
include::{uml_export_dir}/classes/el_literal.adoc[]

include::{uml_export_dir}/classes/el_scoped_ref.adoc[]
include::{uml_export_dir}/classes/el_instantiable_ref.adoc[]
include::{uml_export_dir}/classes/el_agent_call.adoc[]
include::{uml_export_dir}/classes/el_function_call.adoc[]

include::{uml_export_dir}/classes/el_agent.adoc[]
include::{uml_export_dir}/classes/el_function_agent.adoc[]
include::{uml_export_dir}/classes/el_procedure_agent.adoc[]

include::{uml_export_dir}/classes/el_tuple.adoc[]
include::{uml_export_dir}/classes/el_tuple_item.adoc[]

include::{uml_export_dir}/classes/el_constraint_expression.adoc[]
