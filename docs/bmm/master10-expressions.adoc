= Expressions

== Overview

Expressions in BMM are used to specify class invariants, routine pre- and post-conditions, and may be used more generally in other contexts requiring expressions. They are defined by a set of classes prefixed by 'EL', indicating 'expression language'. The BMM Expression Language (BMM-EL) supports the representation of the following:

* classical expressions using unary and binary operators with functional equivalents;
* terminal elements, including:
** literals;
** references to instantiable entities, i.e. object properties and routine variables;
** function calls;
** agents, i.e. delayed function calls with possibly open parameters;
** predicates on other terminal entities, including 'attached' test for Void (null) instance values.

The meta-types defined in this part of the model may be understood as the types of entities in a parse tree or syntax tree (AST). Conversely, one or more expression syntaxes may be parsed into a tree based on the model described here. Note however, that whatever the variation in surface syntax, all such syntaxes parsed this way ultimately have the semantics defined by the BMM-EL meta-model. This is true even for expressions written in a syntax whose published semantics are in fact different, e.g. a well-known programming language.

The UML model of BMM-EL is shown below. 

[.text-center]
.base.elom.expression Package
image::{uml_diagrams_uri}/LANG-elom.expression.svg[id=elom_expression, align="center"]

Apart from `ASSERTION`, all `EL` classes are descendants of the class `EL_EXPRESSION`, which is characterised by the feature `_effective_type()_`. This is the BMM meta-type of the _result type_ of the expression entity when used in an expression; for literals, this is the inferred type; for object references (including function calls), this is the same as the declared type, and for agents it is the meta-type `BMM_SIGNATURE`.

Although the type hierarchy is not complex, it contains particular choices that may not be the same as found in certain other formalisms. Accordingly, the following UML diagram provides an annotated view of the main Terminal meta-types.

[.text-center]
.base.elom.expression Package - Type hierarchy
image::{uml_diagrams_uri}/LANG-elom.expression-type_hierarchy.svg[id=elom_expression_type_hierarchy, align="center"]

== Operator Expressions

BMM contains meta-types representing operators, but assumes that all operators are surface aliases for functions defined on some class. For this reason, an occurrence of an operator within an expression, represented by `EL_OPERATOR`, contains the attribute `_definition_` to refer to the corresponding function call. This  has to be inferred from the types of its operands.

== Constraint Expressions

One class, `EL_CONSTRAINT_EXPRESSION` is included as a hook for specialisation in other models. This class represents a constraint matching expression of the form `<expr> matches <constraint>`. The concrete representation of the constraint is not modelled here, and could be supplied by subtypes.

[.tbd]
TBD: it might also be supplied by the type `C_OBJECT` from the AOM.

== Terminal Entities

=== Literals

A literal value may appear in an expression as a separate entity within an operator expression, as well as a functional call or agent parameter. The literal values that may be used are either instances of the {openehr_foundation_types}[openEHR Foundation Types^] in {openehr_odin}#_leaf_data[ODIN format^], or a complex object instance in structured serial format, specified by `BMM_SERIAL_FORMALISM` if not a primitive type.

=== Feature References

In BMM, a _feature reference_ is any symbolic reference to a class feature or variable that resolves to an object at evaluation time. This includes all referenceable entities within classes except procedures, which have no return value. Concretely, a feature reference takes the form of one of:

* a property name, e.g. `_name_`;
* a constant name, e.g. `_pi_`;
* a variable or parameter name, e.g. `_a_name_`, `_call_name_`;
* a function call.

Function calls are described in detail in the following section.

=== Agents

An agent is the BMM term for a delayed routine call, and has the meta-type `BMM_SIGNATURE`. It usually appears as a standalone expression, or else a parameter within another agent or function call. Agents are described in detail in the following section.

=== Predicates

Predicates in BMM are Boolean-returning terminal expressions taking one feature reference operand.

==== Attached (x)

xxxx

==== Defined (x)

xxxx

== Class Descriptions

include::{uml_export_dir}/classes/assertion.adoc[]
include::{uml_export_dir}/classes/el_expression.adoc[]

include::{uml_export_dir}/classes/el_operator.adoc[]
include::{uml_export_dir}/classes/el_unary_operator.adoc[]
include::{uml_export_dir}/classes/el_binary_operator.adoc[]

include::{uml_export_dir}/classes/el_terminal.adoc[]

include::{uml_export_dir}/classes/el_instance_ref.adoc[]

include::{uml_export_dir}/classes/el_feature_ref.adoc[]
include::{uml_export_dir}/classes/el_instantiable_ref.adoc[]
include::{uml_export_dir}/classes/el_external_ref.adoc[]

include::{uml_export_dir}/classes/el_literal.adoc[]

include::{uml_export_dir}/classes/el_predicate.adoc[]
include::{uml_export_dir}/classes/el_defined.adoc[]
include::{uml_export_dir}/classes/el_attached.adoc[]

include::{uml_export_dir}/classes/el_constraint_expression.adoc[]
