= Class Features

== Overview

Within the definition of each class in a BMM model are found the declarations of its _features_, consisting of _routines_, _properties_ and _constants_. The overall meta-model of features, as well as the elements that occur within them, namely parameters and local variables is shown below, and described in this section.

The taxonomy of meta-types that classify the concrete meta-types representing features is somewhat complicated in an object-oriented approach by the presence of procedures, which are declared features (sometimes called commands or modifiers) that change internal object state, rather than returning a value as is the case with all other kinds of features. The consequence is that the cleanest approach to definition of meta-attributes is the use of two taxonomies, one corresponding to declared features (including procedures) and on to do with typed, value-returning entities, which excludes procedures.

=== Feature Declarations

_Features_ are understood in BMM as entities referenceable within a module or lower context. The 'module' in BMM is the class. Class features consist of the formal sub-parts of a class, namely:

* _routines_: _procedures_ and _functions_;
* _properties_: mutable static definitions, described in detail in previous sections;
* _constants_: immutable static definitions.

Variables are also understood as a kind of class feature, whose scoping entity is further restricted to a containing routine.

The taxonomy of feature declarations is shown below.

[.text-center]
.Feature taxonomy
image::{diagrams_uri}/feature_taxonomy.svg[id=feature_taxonomy, align="center"]

This taxonomy is concerned with model elements that can be lexically declared within some _scope_. Those elements defined within a class scope have a _type signature_, i.e. a formal 'shape' in terms of types. This applies even to _procedures_, which are formal entities despite having no return type.

=== Typed Entities

For entities with a _type_, i.e. which can potentially produce a value, the following taxonomy of typing applies.

[.text-center]
.Typed taxonomy
image::{diagrams_uri}/typed_taxonomy.svg[id=typed_taxonomy, align="center"]

This taxonomy is concerned with typedness, valuedness, and mutability, i.e. the notion that a typed value-producing entity may be Void (null) at execution time. Features, which are declarations _in context_ can be mutable, but value objects (e.g. literal values, delayed routine calls cannot).

=== Class Model

The class model that results from the above considerations is shown below.

[.text-center]
.`base.bmm.core.feature` package - Features
image::{uml_diagrams_uri}/LANG-bmm.core.feature.svg[id=core_feature, align="center"]

== Differential and Flat Form

In modelling or programming terms, the features defined on a particular class within a model constitute the features it _introduces with respect to its inheritance parent(s)_. We can think of this list of features as the _differential_ set. A 'top-level' class with no declared inheritance ancestor is considered to inherit by default from the `Any` class, and its feature set is relationally differential to the top class.

In contrast, the _effective_ set of features for an instance at runtime is the result of evaluating these lists of features down the inheritance hierarchy to obtain the _flat_ set of features. The features _properties_ and _flat_properties_ defined on `BMM_CLASS` provide access to these two lists for any class.

== Signatures

All class-scoped features have formal signatures. The simplest type of signature is that of properties and constants, which may be expressed formally as follows:

----
    : T_result
----

This indicates that both meta-types have a return type, being the type of the value they are attached to at execution time.

The two types of routines, i.e. functions and procedures include zero or more formal parameters in their signatures, with functions also having a return type. The general form of routine signatures is thus as follows:

----
    [T_arg1, T_arg2, ...]: T_result        -- Function
    [T_arg1, T_arg2, ...]                  -- Procedure
----

Typical examples of function signatures:

----
    []: Date                        -- signature of a 0-order function like current_date()
    [Real, Real]: Real              -- signature of a 2nd-order function like '*' for the domain R
    [Integer, Integer]: Integer     -- signature of a 2nd-order function like 'add' for the domain I
----

Typical procedure signatures include the following:

----
    [Real]                          -- a 1st-order procedure for the domain R
    [String, Integer]               -- signature of a procedure taking a String and an Integer argument
----

== Constants

Constant features in a class are represented by the BMM meta-type `BMM_CONSTANT`, which is:

* a descendant of `BMM_CLASS_SCOPED` with a signature having no arguments; and
* a descendant of `BMM_INSTANTIABLE` that is not run-time nullable.

A constant has a `_value_`, which may be of any type, including complex types.

[.tbd]
TBD: add support for computed constants a la Eiffel `once` routines.

== Properties

Class properties are defined via the meta-class `BMM_PROPERTY`, and its subtypes which distinguish _unitary properties_ (single-valued attributes in a class) from _container properties_ (multiply-valued attributes).

The `BMM_PROPERTY` meta-type defines semantics common to all properties, including `_is_composition_`, which indicates whether the property reference instantiates a part-of relationship or an association.

=== Unitary versus Container Properties

Single-valued properties in a BMM model are instances of the type `BMM_UNITARY_PROPERTY`, and have as their `_type_` the meta-type `UNITARY_TYPE`. Container properties are instances of the meta-type `BMM_CONTAINER_PROPERTY`, which adds the attribute `_cardinality_`, enabling the possible number of container elements to be constrained (this corresponds to the multiplicities used at the end of UML associations). The meta-type `BMM_INDEXED_CONTAINER_PROPERTY` adds the attribute `_index_type_`, enabling representation of indexed concrete container types such as `Hash<K,V>` etc.

=== Semantic level

Properties also include two other Boolean meta-data items, `_is_im_runtime_` and `_is_im_infrastructure_`, which can be used to classify property values in a model according to 'semantic level', which roughly corresponds to the continuum from domain-specific to infrastructure. These may be individually set, or both may be False. The three meaningful value settings are as follows:

* _both False_: the value of the property is considered to be design-time constrainable;
* _is IM runtime_: True if the property value is only knowable at runtime, as is typically the case for identifiers, dates etc;
* _is infrastructure_: True if the property is not a user- or business-oriented property, but something required by software design, e.g instance identifier, meta-data etc.

The following example shows a the flattened property view of a class `OBSERVATION` in a BMM model whose flat properties have different settings of the `_is_im_runtime_` and `_is_im_infrastructure_` meta-data flags: property names in black are neither; those in grey are IM runtime, and those in light grey are infrastructure properties.

[.text-center]
.BMM class - properties view
image::{images_uri}/awb_class_properties.png[id=awb_class_properties, align="center", width="50%"]

== Functions and Procedures

Functions and procedures are kinds of _routine_, which are computational features of a class.

The formal parameter definitions of both kinds of routines are represented by an ordered list of instances of the meta-class `BMM_PARAMETER`, which is understood as a kind of _variable_. A formal parameter may optionally have the read/write direction defined, which indicates whether the variable contains an input value, should only be written to, or both, i.e. read then written to. The `_is_nullable_` meta-attribute inherited from `BMM_TYPED_FEATURE` indicates whether each parameter is mandatory or not.

An additional feature of the meta-model for functions is the notion of _operator_, which supports the representation of a function call in a formal expression as an operator symbol with one or two operands, in the typical form found in programming languages and first order logics. The BMM approach considers an operator as an optional addition to any function of `_arity_` 1 or 2 that may reasonably be represented in an abstract syntax using operator syntax. Operators thus support the use of expressions like `weight > 90` to mean `weight.gt (90)`, where `weight` is of type `Real`, and the function `gt(other: Real)` is defined.

== Variables, Objects and Values

At the finest level of detail of a model definition are what are typically thought of as (local) _variables_ and (literal) _values_. These are represented by the classes `BMM_LOCAL` and `BMM_VALUE` respectively. Both variables and values have a `_type_`, with type being inferred for the latter from its value when parsed or otherwise created.

== Class Definitions

include::{uml_export_dir}/classes/bmm_typed.adoc[]

include::{uml_export_dir}/classes/bmm_class_scoped.adoc[]
include::{uml_export_dir}/classes/bmm_typed_feature.adoc[]
include::{uml_export_dir}/classes/bmm_instantiable.adoc[]

include::{uml_export_dir}/classes/bmm_constant.adoc[]

include::{uml_export_dir}/classes/bmm_property.adoc[]
include::{uml_export_dir}/classes/bmm_unitary_property.adoc[]
include::{uml_export_dir}/classes/bmm_container_property.adoc[]
include::{uml_export_dir}/classes/bmm_indexed_container_property.adoc[]

include::{uml_export_dir}/classes/bmm_routine.adoc[]
include::{uml_export_dir}/classes/bmm_function.adoc[]
include::{uml_export_dir}/classes/bmm_operator.adoc[]
include::{uml_export_dir}/classes/bmm_operator_position.adoc[]
include::{uml_export_dir}/classes/bmm_procedure.adoc[]

include::{uml_export_dir}/classes/bmm_variable.adoc[]
include::{uml_export_dir}/classes/bmm_local.adoc[]
include::{uml_export_dir}/classes/bmm_parameter.adoc[]
include::{uml_export_dir}/classes/bmm_parameter_direction.adoc[]

