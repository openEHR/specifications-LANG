= Class Features

== Overview

Within the definition of each class in a BMM model are found the declarations of its _features_, consisting of _routines_, _properties_ and _constants_. The overall meta-model of features, as well as the elements that occur within them, namely parameters and local variables is shown below, and described in this section.

The taxonomy of meta-types that classify the concrete meta-types representing features is somewhat complicated in an object-oriented approach by the presence of _procedures_, which are declared features (sometimes called commands or modifiers) that change internal object state, rather than returning a value as is the case with all other kinds of features. The consequence is that the cleanest approach to definition of meta-attributes is the use of two taxonomies, one corresponding to _feature declarations_ (including procedures) and one to do with _typed value-returning entities_, which excludes procedures.

=== Feature Declarations

_Features_ are understood in BMM as entities referenceable within a module or lower context. The 'module' in BMM is the class. Class features consist of the formal sub-parts of a class, namely:

* _routines_: _procedures_ and _functions_;
* _properties_: mutable static definitions, described in detail in previous sections;
* _constants_: immutable static definitions.

Variables are also understood as a kind of class feature, whose scoping entity is further restricted to a containing routine.

The taxonomy of feature declarations is shown below.

[.text-center]
.Feature taxonomy
image::{diagrams_uri}/feature_taxonomy.svg[id=feature_taxonomy, align="center"]

This taxonomy is concerned with model elements that can be lexically declared within some _scope_. Those elements defined within a class scope have a _type signature_, i.e. a formal 'shape' in terms of types. This applies even to _procedures_, which are formal entities despite having no return type.

=== Typed Entities

For entities with a _type_, i.e. which can potentially produce a value, the following taxonomy of typing applies.

[.text-center]
.Typed taxonomy
image::{diagrams_uri}/typed_taxonomy.svg[id=typed_taxonomy, align="center"]

This taxonomy is concerned with typedness, valuedness, and mutability, which is the notion that a typed value-producing entity may be Void (null) at execution time. Features, which are declarations _in context_ can be mutable, but value objects (e.g. literal values, delayed routine calls) cannot.

=== Class Model

The class model that results from the above considerations is shown below.

[.text-center]
.`base.bmm.core.feature` package - Features
image::{uml_diagrams_uri}/LANG-bmm.core.feature.svg[id=core_feature, align="center"]

=== Differential and Flat Form

In modelling or programming terms, the features defined on a particular class within a model constitute the features it _introduces with respect to its inheritance parent(s)_. We can think of this list of features as the _differential_ set. A 'top-level' class with no declared inheritance ancestor is considered to inherit by default from the `Any` class, and its feature set is relationally differential to the top class.

In contrast, the _effective_ set of features for an instance at runtime is the result of evaluating these lists of features down the inheritance hierarchy to obtain the _flat_ set of features. The features _properties_ and _flat_properties_ defined on `BMM_CLASS` provide access to these two lists for any class.

=== Signatures

All class-scoped features have formal signatures (described in <<Signature Meta-type>>), realised as `BMM_CLASS_SCOPED._signature_`. This includes procedures, even though they have no return type.

The two types of routines, i.e. functions and procedures, include zero or more formal parameters in their signatures, with functions also having a return type. The standard taxonomy of feature signature types is illustrated below, with each form being controlled by invariants stated in the relevant containing meta-classes (e.g. `BMM_FUNCTION`, representing a function definition has an invariant requiring `signature.result /= Void`).

[.text-center]
.Signature taxonomy
image::{diagrams_uri}/signature_taxonomy.svg[id=signature_taxonomy, align="center", width="40%"]

=== Feature Visibility

Selective _visibility_ of features to external clients is expressed in the attribute `BMM_CLASS_SCOPED._visibility_`.

[.tbd]
TBD: define visibility meta-model; probably need to support C/Java approach and type-based.

=== Synthesis due to Generic Parameter Substitution

Due to the possibility of generating concrete types via substitution of concrete generic parameters for formal parameters of generic classes, new concrete types of features may routinely result anywhere in a fully computed in-memory BMM model. BMM allows such features to be synthesised with their resulting concrete types rather than their 'source-defined' open parameter types, and provides the Boolean flag `_is_synthesised_generic_` on the class `BMM_CLASS_SCOPED` to mark any such synthesised feature. An example of the use of this is described below in <<_generic_inheritance>>.

== Constants

Constant features in a class are represented by the BMM meta-type `BMM_CONSTANT`, which is:

* a descendant of `BMM_CLASS_SCOPED` whose `_signature_` has no arguments; and
* a descendant of `BMM_INSTANTIABLE` that is not run-time nullable.

A constant has a `_value_`, which may be of any type, including complex types.

The following abstract syntax illustrates how constants may be defined in a BMM model.

[source,typescript]
----
    // a class with simple invariants
    class BASIC_DEFINITIONS {
        feature
            // some simple constants
            constant CR: Character '\015';
            constant LF: Character '\012';
        
            // constant of complex type
            constant SafeSpeed: Interval<Quantity> {
                "lower": {
                    "value": 0.0,
                    "units": "km/h"
                },
                "upper": {
                    "value": 60.0,
                    "units": "km/h"
                },
                "lower_included": true,
                "upper_included": true                
            }
    }
----

[.tbd]
TBD: add support for computed constants.

== Properties

Class properties are defined via the meta-class `BMM_PROPERTY`, and its subtypes which distinguish _unitary properties_ (single-valued attributes in a class) from _container properties_ (multiply-valued attributes).

The `BMM_PROPERTY` meta-type defines semantics common to all properties, including `_is_composition_`, which indicates whether the property reference instantiates a part-of relationship or an association.

=== Unitary versus Container Properties

Single-valued properties in a BMM model are instances of the type `BMM_UNITARY_PROPERTY`, and have as their `_type_` the meta-type `UNITARY_TYPE`. Container properties are instances of the meta-type `BMM_CONTAINER_PROPERTY`, which adds the attribute `_cardinality_`, enabling the possible number of container elements to be constrained (this corresponds to the multiplicities used at the end of UML associations). The meta-type `BMM_INDEXED_CONTAINER_PROPERTY` adds the attribute `_index_type_`, enabling representation of indexed concrete container types such as `Hash<K,V>` etc.

A typical example of properties of class is shown below, in which the flattened property view of a class `OBSERVATION` includes the inherited properties `_other_participations_` and `_links_` properties exemplifying the container property meta-type:

[.text-center]
.BMM class - properties view
image::{images_uri}/awb_class_properties.png[id=awb_class_properties, align="center", width="50%"]

The following illustrates how various kinds of properties may appear in a BMM model. The first two properties are associations, used to represent references to shared objects (including singletons), while the remainder are normal compositional sub-parts, i.e. owned sub-instances that will cease to exist when the parent object is destroyed. All of the properties are single-valued, other than `other_participations`, which is defined as a container property with cardinality `[\*]` (i.e. `0..*`) and 'set' semantics.

[source,typescript]
----
    abstract class ENTRY {
        inherit
            CARE_ENTRY

        feature -- Locale
            association property language: CODE_PHRASE <<"iso::iso_639-2">> [0..1];
            association property encoding: CODE_PHRASE <<"iana::character-sets">> [0..1];
        
        feature -- Access
            composition property protocol: ITEM_STRUCTURE[1];
            composition property guideline_id: OBJECT_REF[0..1];
            composition property subject: PARTY_PROXY[0..1];
            composition property other_participations: PARTICIPATION[*]{set};
    }
----

=== Semantic level

[.tbd]
TBD: this BMM feature requires review

Properties also include two other Boolean meta-data items, `_is_im_runtime_` and `_is_im_infrastructure_`, which can be used to classify property values in a model according to 'semantic level', which roughly corresponds to the continuum from domain-specific to infrastructure. These may be individually set, or both may be False. The three meaningful value settings are as follows:

* _both False_: the value of the property is considered to be design-time constrainable;
* _is IM runtime_: True if the property value is only knowable at runtime, as is typically the case for identifiers, dates etc;
* _is infrastructure_: True if the property is not a user- or business-oriented property, but something required by software design, e.g instance identifier, meta-data etc.

The above screenshot also includes properties have different settings of the `_is_im_runtime_` and `_is_im_infrastructure_` meta-data flags: property names in black are neither; those in grey are IM runtime (`_guideline_id_`, `_workflow_id_`), and those in light grey are infrastructure properties (`_language_`, `_encoding_`, `_uid_`, etc).

== Functions and Procedures

Functions and procedures are kinds of _routine_, which are computational features of a class. The classes `BMM_FUNCTION`, `BMM_PROCEDURE` and `BMM_ROUTINE` respectively provide the meta-model for _definitions_ of the two types of routine.

The formal parameter definitions of both kinds of routines are represented by an ordered list of instances of the meta-class `BMM_PARAMETER`, which is defined as a kind of _variable_. A formal parameter may optionally have the read/write direction defined, which indicates whether the variable contains an input value, should only be written to, or both, i.e. read then written to. The `_is_nullable_` meta-attribute inherited from `BMM_TYPED_FEATURE` indicates whether each parameter is mandatory or not.

An additional feature of the meta-model for functions is the notion of _operator_, which supports the representation of a function call in a formal expression as an operator symbol with one or two operands, in the typical form found in programming languages and first order logics. The BMM approach considers an operator as an optional addition to any function of `_arity_` 1 or 2 that may reasonably be represented in an abstract syntax using operator syntax. Operators thus support the use of expressions like `weight > 90` to mean `weight.gt (90)`, where `weight` is of type `Real`, and the function `gt(other: Real)` is defined.

Any routine may have pre- and/or post-conditions defined for it, represented in BMM by `EL_ASSERTIONs` populating the `_pre_conditions_` and `_post_conditions_` attributes of `BMM_ROUINE`. An Assertion is a <<_bmm_assertion_class,tagged Boolean Expression>>.

The following abstract syntax illustrates the various elements of function definitions.

[source,typescript]
----
    abstract class DV_AMOUNT {
        inherit
            DV_QUANTIFIED

        feature -- Arithmetic Operations
        
            function equal (other: DV_AMOUNT[1]): Boolean[1] 
                alias {infix '='};
            
            function less_than (other: DV_AMOUNT[1]): Boolean[1] 
                alias {infix '<'};
            
        feature -- Arithmetic Operations
        
            function add (other: DV_AMOUNT[1]): DV_AMOUNT[1] 
                alias {infix '+'};
            
            function subtract (other: DV_AMOUNT[1]): DV_AMOUNT[1] 
                alias {infix '-'};
                
            function multiply (val: Real[1]): DV_AMOUNT[1] 
                alias {infix '*'};
                
            function divide (val: Real[1]): DV_AMOUNT[1] 
                alias {infix '/', infix 'รท'};
                
    }
----

NOTE: not currently supported: 'static' (non-instance dependent) methods; anchored types.

=== Pre- and Post-conditions

All BMM routine definitions may include pre- and/or post-conditions, with the semantics of Djikstra's weakest pre-condition logic (citenp:[Djikstra_DOP_1976]), Object-Z (citenp:[Object_Z]) and the Eiffel language (citenp:[Meyer_OOSC2]).

The essential semantics are as follows:

* _pre-conditions_ specify truth conditions on public object state and/or parameters that must hold for the routine to execute correctly;
** if a pre-condition is not met at the moment of routine call, the client (caller) is at fault;
* _post-conditions_ specify truth conditions on public object state and/or result (in the case of functions) that will hold at the end of routine execution;
** if a post-condition is not met at the moment of routine completion, the routine is at fault, i.e. contains bugs.

The use of pre- and post-conditions is also known as _design by contract (DbC)_, a term introduced by Meyer, and is widely used in general IT, particularly in specification languages such as {omg_idl}[OMG Interface Definition Language (IDL)^].

The following shows how a routine contract may be specified in an abstract syntax.

[source,typescript]
----
    class I_EHR_SERVICE {
        
        feature -- Creation
            
            create_ehr_with_id (
                an_ehr_id: UUID[1];
                an_ehr_status: EHR_STATUS[0..1]
            ): UUID[1]
                pre_condition
                    No_duplicate: not has_ehr (an_ehr_id)
                post_condition
                    Has_ehr: has_ehr (Result)
    }
----

== Variables

At the finest level of detail of a model definition are what are typically thought of as _variables_ within a routine scope. These may be either _local variables_ (variables declared locally within a routine) and parameter variables (declared in the arguments part of a routine declaration). Local variables and parameters have the meta-types `BMM_LOCAL` and `BMM_PARAMETER` respectively.

== Model Theoretic Questions

The features meta-model as defined here entails certain choices that have consequences. The primary choice that affects this part of the meta-model is not to treat `Void` as a type, with the result a _procedure is not a typed entity_, meaning its signature has no result part. This makes procedures an anomaly within an otherwise typed system of entities, and complicates the inheritance structure of the BMM meta-model. The alternative would have been to treat procedures as Void-returning entities, and thus `Void` as a pseudo-type. The major disadvantage of the latter is that it makes procedure definitions (`BMM_PROCEDURE` instances within a BMM model) look like typed entities, and as a result, procedure calls look like value-returning entities that could be used within expressions (i.e. no different than function calls).

Ultimately this difficulty arises from the decision to include procedures at all within the formal framework, when from a purely functional perspective they would not exist. Avoiding procedures means going down a pure functional route, which, although providing a cleaner model of computation, inevitably entails various artificial and non-intuitive means of making a computational entity _do_ something. In BMM we have taken the route of objects as black boxes having displays (functions) and controls (procedures), with well-behaved models relying on command-query separation, i.e. side-effect free functions. The latter principle is not enforced by BMM, but its use would make a formal model expressed in BMM more tractable to proof-based tools.

== Class Definitions

include::{uml_export_dir}/classes/bmm_typed.adoc[]

include::{uml_export_dir}/classes/bmm_class_scoped.adoc[]
include::{uml_export_dir}/classes/bmm_typed_feature.adoc[]
include::{uml_export_dir}/classes/bmm_instantiable.adoc[]

include::{uml_export_dir}/classes/bmm_constant.adoc[]

include::{uml_export_dir}/classes/bmm_property.adoc[]
include::{uml_export_dir}/classes/bmm_unitary_property.adoc[]
include::{uml_export_dir}/classes/bmm_container_property.adoc[]
include::{uml_export_dir}/classes/bmm_indexed_container_property.adoc[]

include::{uml_export_dir}/classes/bmm_routine.adoc[]
include::{uml_export_dir}/classes/bmm_function.adoc[]
include::{uml_export_dir}/classes/bmm_operator.adoc[]
include::{uml_export_dir}/classes/bmm_operator_position.adoc[]
include::{uml_export_dir}/classes/bmm_procedure.adoc[]

include::{uml_export_dir}/classes/bmm_variable.adoc[]
include::{uml_export_dir}/classes/bmm_local.adoc[]
include::{uml_export_dir}/classes/bmm_parameter.adoc[]
include::{uml_export_dir}/classes/bmm_parameter_direction.adoc[]

