= Overview

The openEHR Expression Language (EL) defines a syntax and grammar for the expressions whose meta-model is defined in the `expression` package in the {openehr_bmm}[openEHR Basic Meta-Model (BMM)^]. As such it may be considered the default syntax. Other syntaxes or syntax variants are certainly possible, and other expression serialisation are possible, such as object graph serialisation into XML, JSON, YAML etc.

Consequently, the BMM `expression` package should be considered the normative definition of openEHR EL. Not all openEHR implementations using BMM expressions need support it: they might for example only serialse in JSON or use purely graphical visualisation.

Key features of the formalism include:

* variable declarations, assignments and expressions;
* strong typing;
* standard logical operators including universal and existential quantification, as well as user-defined operators;
* standard arithmetic and relational comparison operators, enabling the use of numerics;
* parentheses for overridding operator precedence;
* functions and agents (lambdas).

== Design Background

The openEHR Expression formalism is based on a limited first-order predicate logic language with extensions for numeric sub-expressions. It has similarities with OMG's OCL (Object Constraint Language) syntax, and is also similar to the assertion syntax used in the citenp:[Object_Z] language (see citenp:[Sowa2000], citenp:[Hein2002], citenp:[Kilov1994] for an explanation of predicate logic in information modelling). It is not exactly the same as any of these languages because:

* it has a different target meta-model, namely the BMM `expression` package;
* the syntax is designed to be comprehensible to developers familiar with modern mainstream object-oriented and functional languages such as Java, C#, Python, TypeScript etc.

== Requirements

The semantic requirements including the usual arithmetic, boolean, and relational operators, functions, logical quantifiers, operator precedence, constant values, and variables. In addition, there is a need to support multi-lingual translations for symbolic variables, in a similar way to the {openehr_am_adl2}[openEHR Archetype Definition Language (ADL2)^].

== Execution Model

The assumed execution model of the Expression language is that EL statements are evaluated by an _evaluator_ against a _data context_, which determines the truth values of the expression(s). The data context is the origin for some or all of the variables mentioned in the expressions, which may be read from and written to. It may concretely be a retrieved data structure, or data via an API call to the EHR, demographics, laboratory system etc.

The data context may be specified in two ways. It may be inferrable from the artefact or computing context in which the EL statements appear, or it may be specified explicitly. In the former case, the EL instance is minimally a value-returning logical proposition such as `systolic_pressure > 0`, where the declaration of variables or properties such as `systolic_pressure` are inferred from e.g. a data binding, and any manifest values obey this EL specification. The implicit case is shown below.

[.text-center]
.EL execution model - implicit context
image::{diagrams_uri}/EL_design_structure-implicit.svg[id=EL_design_structure_implicit, align="center"]

In the explicit form, an EL expressions appear within a BMM model definition, or within a context that explicitly imports a BMM model.

[.text-center]
.EL execution model - explicit context
image::{diagrams_uri}/EL_design_structure-explicit.svg[id=EL_design_structure_explicit, align="center"]

In both cases, the result of parsing into computable form for evaluation must result in instance of the BMM EL meta-types.

== Expressions and Ontic Truth

No assumption is made about whether the data context used is complete or faithful to reality. Consequently, the _expression universe_ is technically speaking an 'open world' in the sense of the {wikipedia_open_world_assumption}[open-world assumption^]. However, higher-level applications or components (or users) may have sufficient knowledge about the data as to be able to treat it in a closed world fashion, for example to treat absence of X as negation of X.

