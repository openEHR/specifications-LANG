= EL Expressions

== Overview

Formally, an openEHR EL expression is any of the following evaluable entities:

* _terminal entities_:
** _instance references_, including _literals_, _constants_, _variables_ and _function calls_;
** _predicates_: Boolean tests on instance structures;
** _agents_: i.e. delayed routine calls;
* _complex expressions_ created from:
** _equality operator_: equality operator;
** _primitive operators_: arithmetic operators, relational operators, boolean operators;
** _collection operators_: logical quantification operators.

These correspond to the meta-types defined in the {openehr_bmm}##_expressions[BMM `expression` package^], each of which is described in detail in the following sub-sections.

EL is not intended for writing functions or classes, rather it is designed as a minimalist logic-based language in which expressions can be written, but whose programming is undertaken inside libraries in existing programming languages. Routine declarations in EL are the primary mechanism to connect external software libraries to the EL context. In EL, both functions and procedures are supported, and are collectively known as _routines_.

== Terminal Entities

Terminal entities in EL correspond to the `EL_TERMINAL` meta-type in BMM, and its descendants. These come in three categories: 

* _instance references_: references to instances generated by direct references to _literals_, _constants_, _variables_, or else _function calls_;
* _predicates_: logical conditions on instance references;
* _agents_: delayed routine call objects.

The following sub-sections describe these types.

=== Instance References

==== Literals

Literal values are expressed in the {openehr_odin}#_primitive_types[openEHR ODIN syntax^], with the exception of `List<T>` and `Set<T>` which are distinguished in EL with specific types of brackets. The corresponding classes are described in the {openehr_foundation_types}[openEHR Foundation Types specification^].

[cols="1,2,3",options="header"]
|=================================================================
|Type                   |Literal values                         |Description

| `Boolean`             |`True`, `False`                        |
|                       |                                       |
| `Integer`             |`10`, `-4`, `1024`                     |Signed values from −2^31^ to 2^31^-1
| `Real`                |`10.0`, `0.345`                        |Signed values from 3.4028235 × 10^38^
| `Double`              |`10`, `-4`, `1024`                     |
|                       |                                       |
| `Date`                |`2004-08-12`                           |ISO 8601-format date
| `Date_time`           |`2004-08-12T12:00:59+0100`             |ISO 8601-format date/time
| `Time`                |`12:00:59`                             |ISO 8601-format time
| `Duration`            |`P39W`                                 |ISO 8601-format duration
|                       |                                       |
| `String`              |`"this is a string"`                   |
|                       |`[blood_pressure]`                     |Extract the string value for the symbol `blood_pressure` from the EL terminology
| `Uri`                 |`https://en.wikipedia.org/wiki/Everest`|Uri in {rfc3986}[IETF RFC 3986^] format
| `Terminology_code`    |`[snomed_ct::389086002]` +
                         `[snomed_ct::389086002\|Hypoxia\|]`    |Terminology code in openEHR format
|                       |                                       |
| `List<T>`             |`[val, val, ...]`                      |
| `Set<T>`              |`{val, val, ...}`                      |
| `Hash<K:Ordered, V>`  |`< +
                              ["key1"] = <val1> +
                              ["key2"] = <val2> +
                              ... +
                              ["keyN"] = <valN> +
                         >`                                     |A table of values of any type V, +
                                                                 keyed by values of any `Ordered` descendant K, +
                                                                 typically `String` or `Integer`
|                       |                                       |
| `Interval<T>`         |                                       |
|                       |`\|N..M\|`                             |the two-sided interval N >= x \<= M
|                       |`\|>N..M\|`                            |the two-sided interval N > x \<= M
|                       |`\|N..<M\|`                            |the two-sided interval N >= x < M
|                       |`\|<N\|`                               |the one-sided interval x < N
|                       |`\|>N\|`                               |the one-sided interval x > N
|                       |`\|\<=N\|`                             |the one-sided interval x \<= N
|                       |`\|>=N\|`                              |the one-sided interval x >= N
|                       |`\|N +/-M\|`                           |the two-sided interval of N ±M
|                       |`\|N±M\|`                              |the two-sided interval of N ±M
|=================================================================

==== Constants

Constants are syntactically represented using labels of which the first letter is capitalised, and may be of any type, including complex types. The following are EL expressions containing constants.

[source,typescript]
--------
    Mph_to_kmh_factor = 1.6
    Safe_glucose_limits.has (3.5)
--------

==== Variables

Symbolic variables are valid within the scope of the routine in which they are declared. They are represented by plain names such as `is_smoker`. An EL variable reference corresponds to a descendant of the BMM meta-type `EL_INSTANTIABLE_REF<BMM_VARIABLE>`, either `EL_INSTANTIABLE_REF<BMM_PARAMETER>` (declared in the routine signature) or `EL_INSTANTIABLE_REF<BMM_LOCAL>` (declared as a routine local variable).

==== Property References

Property references are valid within the scope of the class in which they are declared, and may be used in any routine definition or assertion in the class. They are represented by plain names such as `diabetic_status`. 

==== Function Calls

In EL expressions, computational functions may be called in the same way as for typical programming languages. An EL property reference corresponds to the BMM meta-type `EL_FUNCTION_CALL`, which contains an instance of the BMM meta-type `EL_FUNCTION_AGENT`, which in turn has as its `_closed_args_` a tuple containing a set of items each of which is in turn an expression of any kind.

Consequently, EL function calls (similarly to most programming languages) may be of any level of complexity. The simplest type of function call is to a function whose signature is `<[],T>`, i.e. one taking no arguments are returning a value of type `T`. In EL, this may be called with or without parentheses, e.g. `age` or `age()`.

The following example assumes a function `tnm_major_number (tnm_val: String): Integer` that extracts various elements of {wikipedia_tnm}[Tumour/Node/Metastasis ('TNM')^] cancer staging values, such as `'Tis'`, `'G3'` and so on, and shows two forms of call to this function.

[source,typescript]
----
    tnm_major_number (tnm_t)
    tnm_major_number ("Tis")
----

More complex function calls may include arguments of other function calls, agents, tuples, operator expressions and normal instance references.

To be evaluated, function calls must be mappable to class methods in external libraries that are available at expression evaluation time.

==== 'Built-in' Functions

Some commonly used functions such as `current_date()` or similar are often thought of as 'built-in' to a language environment. In the openEHR EL context, there are no built-in functions as such; useful utility functions must be supplied by classes or interfaces included as part of an imported model. In the openEHR environment, many utility calls are available in the {openehr_base_types}[openEHR Base Types^]. They will resolve correctly as long as this model is imported, which it normally will be as part of a larger model, such as the {openehr_rm}[openEHR RM^].

As a consequence, the total set of available utility functions for use in an EL expression is just what is available from the sum of all imported models. Assuming the openEHR Foundation and Base Types, the following kinds of functions are available for use in EL expressions:

[source,typescript]
----
    {Env}.current_date                                      // obtain today's date as a Iso8601_date
    
    blood_glucose_list: List<Real>
    {Statistical_evaluator}.max (blood_glucose_list)        // compute a maximum of Numerics

    {Locale}.language                                       // the primary language in the locale as a Coded_term
----

==== Self Reference

As with many programming languages, a pre-defined reference to the current object is available via the plain name `self`. Unlike some languages, 'self' is not needed as a qualifier for properties or functions, and is generally only used as an argument in function calls.

=== Predicates

EL predicates are special meta-operators that enable execution to be modified depending on the truth values and availability of referenced data items.

==== defined() Predicate

[.tbd]
TBD: to be rewritten

Variables that are bound to entities in the data context function differently from local variables, since their availability is predicated on the existence of the relevant entities. For example, the variable `body_weight` may be bound to a call that retrieves a patient weight from the EHR, via an appropriate API call. There is no guarantee that the value is available, so `body_weight` may therefore be undefined in a sense not applicable to local variables. In a programming language, if a variable is not explicitly set, it has either the default value of the type (e.g. `0` for `Integer`) or a random value of the correct type. This behaviour is appropriate for local variables, but for external variables that cannot be evaluated because the external entity does not exist, an explicit mechanism is needed to test for validity.

The approach used for EL is to allow external variables to be used freely, as for local variables, but if an external variable cannot be evaluated from the data context, an `'undefined value'` exception is generated, indicating which variable could not be evaluated. The `defined()` predicate provides a way of making an explicit check to avoid an exception, as follows.

----
    if defined (heart_rate) and defined (blood_pressure) then
        -- statements mentioning heart_rate and blood_pressure
    end
----

Another difference between external and local variables is when they are evaluated. In the execution of a larger EL Module containing multiple mentions of an external variable `v`, is `v` read from the data context only once, at the first mention, or is it evaluated new each time, or on some other basis? The approach used in EL is to allow the evaluation basis to be stated in the context binding section of an EL Module using the `_currency_` property.

=== Agents

Delayed routine calls for both functions and procedures may occur as terminals in an EL expression. The evaluation type (`_eval_type_`) of an agent is its `_signature_`. Syntactically, these take various forms. An agent can be created using a function or procedure visible in the current scope, using the keyword `agent`. The arguments list may range from empty to full. For a completely empty list, the routine name on its own may be used.

[source,typescript]
----
    // define a naive obstetric risk function
    obstetric_risk (age: Duration[1]; previous_pregnancies: Integer[1]): Coded_term[1] 
    
    agent obstetric_risk                // generate an agent with signature <[Duration, Integer], Coded_term>
----

For a partial argument list, `?` symbols are used for the non-filled arguments. This generates an agent whose signature corresponds to the remaining open arguments. In the following example, an agent of the signature `<[Integer], Coded_term>` is generated, which, since the age of 38 years is supplied, may be thought of as a new function called `obstetric_risk_38_years()`.

[source,typescript]
----
    agent obstetric_risk ('P38Y', ?)    // generate an agent with signature <[Integer], Coded_term>
----

Theoretically, an agent could be created with all arguments supplied, without the intention of immediate execution, e.g. `agent obstetric_risk ('P38Y', 2)`, which would generate an agent of signature `<[],Coded_term>`. This could be later executed by simply using the receiver variable or parameter reference in the normal way, in a later expression.

Agents for procedure calls can be created in the same way as described above. In each case, the evaluation type is a signature of the form `<[args]>`, i.e. having no return type.

=== Qualified Referencing

Any terminal entity may appear as itself (in the relevant syntactic form described below) or in a form qualified by an instance reference, using standard 'dot' referencing. The qualifier provides the reference context, and is represented by the `EL_TERMINAL` property `_context_`. Multiple qualifiers may be used in a single reference, as long as class feature visibility is satisfied, allowing such things as the following:

[source,typescript]
----
    person1.name
    employees.first().name.first_name
    blood_pressure.history.events(3).data.data.systolic
    
    agent obstetric_risks.basic_risk
----

== Complex Expressions

Complex expressions in EL consist of non-atomic value-returning expressions, in a typed, operator-based syntax common to many programming languages and logics. In EL, the syntactic use of operators is understood as a shorthand for specific functions assumed to be available on types inferred from the context of the operator use. An EL implementation would therefore map such operators to the appropriate methods in a class library.

=== Equality Operator

The equality operator `=` in EL is understood as the function `_equal_()` defined on the openEHR Foundation type `Any`, of which every other class is a descendant. For all primitive value types (types for which use in expressions directly generates values rather than instance references), the semantics are value comparison, while for all other types, the semantics are reference comparison. For non-openEHR models, `=` will normally map to a similarly-named method, e.g. `_equals_()`.

To obtain value comparison for non-value types, the function `Any._is_equal_()`, which may be redefined in any sub-type, is used.

=== Primitive Operators

Primitive operators in EL are the infix or prefix syntax form of various functions available on primitive types. For example, the operator `-` (minus) is defined on the class `Numeric` (an inheritance ancestor of the classes `Integer`, `Real` etc) as the following:

[source,typescript]
----
    // in Numeric
    subtract (other: Numeric): Numeric
        alias infix '-'
    
    // redefined in Integer as
    subtract (other: Integer): Integer
----

This means that where the expression `100 - 5` is encountered in EL, what is really invoked is `Integer._subtract_()`, specifically `100._subtract_(5)`.

For convenience, the operators for the `Numeric` and `Boolean` types from the {openehr_foundation_types}[openEHR Foundation Types^] are shown below.

[cols="1,1,3",options="header"]
|=================================================================
|Function                   |Operators     |Meaning
                               
3+^h|Arithmetic Operators - Numeric operands and result; descending precendence order

|`exponent()`               |`^`           |Exponentiation
|`multiply()`               |`*`           |Multiplication
|`divide()`                 |`/`           |Division
|`modulus()`                |`%`           |Modulo (whole number) division
|`add()`                    |`+`           |Addition
|`subtract()`               |`-`           |Subtraction

3+^h|Relational Operators - Numeric, Date/time operands and Boolean result; equal precedence

|`equal()`                  |`=`           |Value equality
|`not_equal()`              |`!=`, `≠`     |Inequality relation
|`less_than()`              |`<`           |Less than relation
|`less_than_or_equal()`     |`\<=`, `≤`    |Less than or equal relation
|`greater_than()`           |`>`     `     |Greater than relation
|`greater_than_or_equal()`  |`>=`, `≥`     |Greater than or equal relation

3+^h|Logical Operators - Boolean operands and result; descending precendence order

|`not()`                    |`not`, `~`    |Negation, "not p"
|`conjunction()`            |`and`, `∧`   |Logical conjunction, "p and q"
|`disjunction()`            |`or`, `∨`    |Logical disjunction, "p or q"
|`exclusive_disjunction()`  |`xor`, `⊻`    |Exclusive or, "only one of p or q"
|`implication()`            |`implies`, `⇒`|Material implication, "p implies q", or "if p then q"

|=================================================================

In addition, some operators are defined on the other primitive types, including the following.

[cols="1,4,2",options="header"]
|=================================================================
|Operator        |Function   	                                                       |Meaning
                               
3+^h|String Operators

|`+`             |`String.append(other: String): String`                               |String concatenation, appending

3+^h|Date/time arithmetic operators

|`+`             |`Iso8601_date.add(d: Iso8601_duration): Iso8601_date`                 |Add a duration to a date
|`+`             |`Iso8601_time.add(d: Iso8601_duration): Iso8601_time`                 |Add a duration to a time
|`+`             |`Iso8601_date_time.add(d: Iso8601_duration): Iso8601_date_time`       |Add a duration to a date/time

|`-`             |`Iso8601_date.subtract(d: Iso8601_duration): Iso8601_date`            |Subtract a duration from a date
|`-`             |`Iso8601_time.subtract(d: Iso8601_duration): Iso8601_time`            |Subtract a duration from a time
|`-`             |`Iso8601_date_time.subtract(d: Iso8601_duration): Iso8601_date_time`  |Subtract a duration from a date/time

|`-`             |`Iso8601_date.diff(d: Date): Iso8601_duration`                        |Difference of two dates
|`-`             |`Iso8601_time.diff(d: Time): Iso8601_duration`                        |Difference of two times
|`-`             |`Iso8601_date_time.diff(d: Date_time): Iso8601_duration`              |Difference of two date/times

3+^h|Duration arithmetic operators

|`+`             |`Iso8601_duration.add(d: Iso8601_duration): Iso8601_duration`         |Add a duration to a duration
|`-`             |`Iso8601_duration.subtract(d: Iso8601_duration):Iso8601_duration`     |Subtract a duration from a duration

|=================================================================

Operator semantics that require further explanation are described below.

==== Logical Negation

All Boolean operators take Boolean operands and generate a Boolean result. The `not` operator can be applied as a prefix operator to all operators returning a Boolean result as well as a parenthesised Boolean expression.

==== Precedence and Parentheses

The precedence of operators follows the order shown in the operator tables above. To change precedence, parentheses can be used in the fashion typical of most programming languages, as shown below.

[source,typescript]
--------
    systolic_bp > 140 and (is_smoker or is_hypertensive)
--------

=== Matches Operator

[.tbd]
TBD: describe

[cols="1,1,3",options="header"]
|=================================================================
|Function               |Operators     |Meaning
                               
3+^h|Constraint Operators - Boolean result

|matches         		|`∈`  		  |Set membership, as per {openehr_am_adl2}[openEHR ADL]

|=================================================================

=== Collection Operators

The two standard quantification operators from predicate logic `there exists` (∃ operator) and `for all` (∀ operator) are defined in EL for the container types found in the {openehr_foundation_types}[openEHR Foundation Types^].

One syntax of `there exists` is as follows:

----
    there_exists v in container_var : <Boolean expression mentioning v> 
----

Here, the `:` symbol is usually read in English as 'such that'. The above may also be expressed in EL as its functional equivalent:

[source,typescript]
----
    list_of_reals: List<Real>
    
    // an expression that will return true if list_of_reals
    // contains a value greater than 140.0
    list_of_reals.there_exists (
        agent (v: Real): Boolean {
            v > 140.0
        }
    )
----

The `for_all` operator has similar syntax:

----
    for_all v in container_var : <Boolean expression mentioning v>
----

Here, the `:` symbol is normally read as 'it holds that' The above may also be expressed in EL as its functional equivalent:

[source,typescript]
----
    list_of_reals: List<Real>
    
    // an expression that will return true if list_of_reals
    // consists of values all greater than 140.0
    list_of_reals.for_all (
        agent (v: Real): Boolean {
            v > 140.0
        }
    )
----
