=== BMM_CONTAINER_TYPE Class

[cols="^1,3,5"]
|===
h|*Class*
2+^h|*BMM_CONTAINER_TYPE*

h|*Description*
2+a|Meta-type that specifies linear containers with a generic parameter corresponding to the type of contained item, and whose container type is a generic type such as `List<T>`, `Set<T>` etc.

h|*Inherit*
2+|`BMM_TYPE`

h|*Attributes*
^h|*Signature*
^h|*Meaning*

h|*1..1*
|*container_class*: `BMM_GENERIC_CLASS`
a|The type of the container. This converts to the `_root_type_` in `BMM_GENERIC_TYPE`.

h|*1..1*
|*item_type*: `BMM_UNITARY_TYPE`
a|The container item type.

h|*0..1*
|*is_ordered*: `Boolean`
a|True indicates that order of the items in the container attribute is considered significant and must be preserved, e.g. across sessions, serialisation, deserialisation etc. Otherwise known as 'list' semantics.

h|*0..1*
|*is_unique*: `Boolean`
a|True indicates that only unique instances of items in the container are allowed. Otherwise known as 'set' semantics.
h|*Functions*
^h|*Signature*
^h|*Meaning*

h|(effected)
|*type_name* (): `String`
a|Return full type name, e.g. `List<ELEMENT>`.

h|(effected)
|*is_abstract* (): `Boolean` +
*_Post_is_abstract_*: `Result = container_type.is_abstract`
a|True if the container class is abstract.

h|(effected)
|*flattened_type_list* (): `List<String>` +
*_Post_result_*: `Result = item_type.flattened_type_list`
a|Flattened list of type names with container type name abstracted away.

h|(effected)
|*unitary_type* (): `BMM_UNITARY_TYPE`
a|Return `_item_type_`.

h|(effected)
|*is_primitive* (): `Boolean` +
*_Post_result_*: `Result = item_type.is_primitive`
a|True if `_item_type_` is primitive.
|===
